<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_src_2eparser_8cpp_source" xml:lang="en-US">
<title>eparser.cpp</title>
<indexterm><primary>src/eparser.cpp</primary></indexterm>
Go to the documentation of this file.<programlisting linenumbering="unnumbered"><anchor xml:id="_src_2eparser_8cpp_source_1l00001"/>00001 
<anchor xml:id="_src_2eparser_8cpp_source_1l00009"/>00009 <emphasis role="preprocessor">#include&#32;&quot;<link linkend="_eparser_8h">eparser.h</link>&quot;</emphasis>
<anchor xml:id="_src_2eparser_8cpp_source_1l00014"/><link linkend="_classemthp_1_1Lexer_1ad3560b27e6813e3e0aeaa48b19dc5dd2">00014</link> <link linkend="_classemthp_1_1Lexer_1ad3560b27e6813e3e0aeaa48b19dc5dd2">emthp::Lexer::Lexer</link>(<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;input)&#32;noexcept&#32;:&#32;_input(this-&gt;clean(input)),&#32;_pos(0)&#32;{}
<anchor xml:id="_src_2eparser_8cpp_source_1l00020"/><link linkend="_classemthp_1_1Lexer_1a5116f34af8ec69634dc9202ae2d48b4a">00020</link> <link linkend="_classemthp_1_1Lexer">emthp::Lexer</link>&amp;&#32;<link linkend="_classemthp_1_1Lexer_1a5116f34af8ec69634dc9202ae2d48b4a">emthp::Lexer::operator =</link>(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classemthp_1_1Lexer">emthp::Lexer</link>&amp;&#32;ogn)&#32;<emphasis role="keyword">noexcept</emphasis>&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00021"/>00021 &#32;&#32;&#32;&#32;this-&gt;_input&#32;=&#32;ogn._input;
<anchor xml:id="_src_2eparser_8cpp_source_1l00022"/>00022 &#32;&#32;&#32;&#32;this-&gt;_pos&#32;=&#32;ogn._pos;
<anchor xml:id="_src_2eparser_8cpp_source_1l00023"/>00023 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00024"/>00024 };
<anchor xml:id="_src_2eparser_8cpp_source_1l00029"/><link linkend="_classemthp_1_1Lexer_1a629ea5f393603e05dad17b004caba27d">00029</link> <link linkend="_structemthp_1_1Token">emthp::Token</link>&#32;<link linkend="_classemthp_1_1Lexer_1a629ea5f393603e05dad17b004caba27d">emthp::Lexer::next</link>()&#32;noexcept&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00030"/>00030 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_pos&#32;&gt;=&#32;this-&gt;_input.size())&#32;{<emphasis role="keywordflow">return</emphasis>&#32;{emthp::TokenType::T_EOF,&#32;{0}};}&#32;<emphasis role="comment">//Returs&#32;EOL&#32;on&#32;end&#32;of&#32;_input</emphasis>
<anchor xml:id="_src_2eparser_8cpp_source_1l00031"/>00031 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(this-&gt;_input[this-&gt;_pos])&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00032"/>00032 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{<link linkend="_namespaceemthp_1a29873cfffe66c1e0b36436ebcc54dc6bab0be00ab2ea8e4a56ab22f220c7de9bf">emthp::TokenType::T_PLUS</link>,&#32;{0}};
<anchor xml:id="_src_2eparser_8cpp_source_1l00033"/>00033 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{emthp::TokenType::T_MINUS,&#32;{0}};
<anchor xml:id="_src_2eparser_8cpp_source_1l00034"/>00034 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;^&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{emthp::TokenType::T_EXPONENT,&#32;{0}};
<anchor xml:id="_src_2eparser_8cpp_source_1l00035"/>00035 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;x&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{emthp::TokenType::T_VARIABLE,&#32;{0}};
<anchor xml:id="_src_2eparser_8cpp_source_1l00036"/>00036 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;*&apos;</emphasis>:&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;/&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_classemthp_1_1Lexer_1a629ea5f393603e05dad17b004caba27d">next</link>();
<anchor xml:id="_src_2eparser_8cpp_source_1l00037"/>00037 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">default</emphasis>:
<anchor xml:id="_src_2eparser_8cpp_source_1l00038"/>00038 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;number&#32;=&#32;this-&gt;read_number();
<anchor xml:id="_src_2eparser_8cpp_source_1l00039"/>00039 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>(<emphasis role="keyword">true</emphasis>)&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00040"/>00040 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(this-&gt;_input[this-&gt;_pos])&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00041"/>00041 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;*&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;number&#32;*=&#32;this-&gt;read_number();&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00042"/>00042 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;/&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;number&#32;/=&#32;this-&gt;read_number();&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00043"/>00043 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;^&apos;</emphasis>:&#32;this-&gt;_pos++;&#32;number&#32;=&#32;std::pow(number,&#32;this-&gt;read_number());&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00044"/>00044 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">default</emphasis>:&#32;<emphasis role="keywordflow">return</emphasis>&#32;{emthp::TokenType::T_NUMBER,&#32;{number}};
<anchor xml:id="_src_2eparser_8cpp_source_1l00045"/>00045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00046"/>00046 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00047"/>00047 &#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00048"/>00048 }
<anchor xml:id="_src_2eparser_8cpp_source_1l00052"/><link linkend="_classemthp_1_1Lexer_1a273b288699191ec896c9857cfe7f5704">00052</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_classemthp_1_1Lexer_1a273b288699191ec896c9857cfe7f5704">emthp::Lexer::back</link>()&#32;noexcept&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00053"/>00053 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_pos&#32;&lt;=&#32;0)&#32;{<emphasis role="keywordflow">return</emphasis>;}&#32;
<anchor xml:id="_src_2eparser_8cpp_source_1l00054"/>00054 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(emthp::Lexer::is_digit(this-&gt;_input[this-&gt;_pos-1]))&#32;{<emphasis role="keywordflow">while</emphasis>&#32;(emthp::Lexer::is_digit(this-&gt;_input[this-&gt;_pos-1]))&#32;{this-&gt;_pos--;}&#32;<emphasis role="keywordflow">return</emphasis>;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00055"/>00055 &#32;&#32;&#32;&#32;this-&gt;_pos--;<emphasis role="keywordflow">return</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00056"/>00056 }
<anchor xml:id="_src_2eparser_8cpp_source_1l00062"/>00062 std::string&#32;emthp::Lexer::clean(<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;input)&#32;<emphasis role="keyword">noexcept</emphasis>&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00063"/>00063 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;pos&#32;=&#32;0;&#32;std::string&#32;string;
<anchor xml:id="_src_2eparser_8cpp_source_1l00064"/>00064 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(pos&#32;&lt;&#32;input.size())&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00065"/>00065 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(input[pos])&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00066"/>00066 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>:&#32;<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00067"/>00067 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>:&#32;<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00068"/>00068 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;*&apos;</emphasis>:&#32;<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;<emphasis role="charliteral">&apos;*&apos;</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00069"/>00069 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;/&apos;</emphasis>:&#32;<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;<emphasis role="charliteral">&apos;/&apos;</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00070"/>00070 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;^&apos;</emphasis>:&#32;<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;<emphasis role="charliteral">&apos;^&apos;</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00071"/>00071 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<emphasis role="charliteral">&apos;x&apos;</emphasis>:&#32;<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;<emphasis role="charliteral">&apos;x&apos;</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00072"/>00072 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">default</emphasis>:&#32;<emphasis role="keywordflow">if</emphasis>&#32;(emthp::Lexer::is_digit(input[pos]))&#32;{<emphasis role="keywordtype">string</emphasis>&#32;+=&#32;input[pos];}&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00073"/>00073 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00074"/>00074 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
<anchor xml:id="_src_2eparser_8cpp_source_1l00075"/>00075 &#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00076"/>00076 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;string;
<anchor xml:id="_src_2eparser_8cpp_source_1l00077"/>00077 }
<anchor xml:id="_src_2eparser_8cpp_source_1l00082"/>00082 <emphasis role="keywordtype">double</emphasis>&#32;emthp::Lexer::read_number()&#32;noexcept&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00083"/>00083 &#32;&#32;&#32;&#32;std::string&#32;snum;
<anchor xml:id="_src_2eparser_8cpp_source_1l00084"/>00084 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(this-&gt;_pos&#32;&lt;&#32;this-&gt;_input.size()&#32;&amp;&amp;&#32;emthp::Lexer::is_digit(this-&gt;_input[this-&gt;_pos]))&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00085"/>00085 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;snum&#32;+=&#32;this-&gt;_input[this-&gt;_pos];
<anchor xml:id="_src_2eparser_8cpp_source_1l00086"/>00086 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_pos++;
<anchor xml:id="_src_2eparser_8cpp_source_1l00087"/>00087 &#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00088"/>00088 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(snum.empty())&#32;{<emphasis role="keywordflow">return</emphasis>&#32;1;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00089"/>00089 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::stod(snum);&#32;<emphasis role="comment">//&#32;CHECK&#32;:&#32;2x^2&#32;--&#32;8x^3/3&#32;;;;.......................4x^1&#32;+&#32;2x⁶</emphasis>
<anchor xml:id="_src_2eparser_8cpp_source_1l00090"/>00090 }
<anchor xml:id="_src_2eparser_8cpp_source_1l00095"/><link linkend="_classemthp_1_1Parser_1a4eb818d42bac1e3e3419c848e521cbdb">00095</link> <link linkend="_classemthp_1_1Parser_1a4eb818d42bac1e3e3419c848e521cbdb">emthp::Parser::Parser</link>(<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;input)&#32;noexcept&#32;:&#32;_lexer(input)&#32;{};
<anchor xml:id="_src_2eparser_8cpp_source_1l00101"/><link linkend="_classemthp_1_1Parser_1ada7e099319ce350bb2d5dcfd5ea8b36a">00101</link> <link linkend="_classemthp_1_1Parser">emthp::Parser</link>&amp;&#32;<link linkend="_classemthp_1_1Parser_1ada7e099319ce350bb2d5dcfd5ea8b36a">emthp::Parser::operator =</link>(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classemthp_1_1Parser">emthp::Parser</link>&amp;&#32;ogn)&#32;<emphasis role="keyword">noexcept</emphasis>&#32;{this-&gt;_lexer&#32;=&#32;ogn._lexer;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;};
<anchor xml:id="_src_2eparser_8cpp_source_1l00106"/><link linkend="_classemthp_1_1Parser_1a933df3ba2501887aa6d947bfe6eafe4b">00106</link> <link linkend="_classemth_1_1Polynomial">emth::Polynomial</link>&#32;<link linkend="_classemthp_1_1Parser_1a933df3ba2501887aa6d947bfe6eafe4b">emthp::Parser::parse_polynomial</link>()&#32;noexcept&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00107"/>00107 &#32;&#32;&#32;&#32;<link linkend="_classemth_1_1Polynomial">emth::Polynomial</link>&#32;polynomial;
<anchor xml:id="_src_2eparser_8cpp_source_1l00108"/>00108 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(<emphasis role="keyword">true</emphasis>)&#32;{<emphasis role="keywordflow">if</emphasis>(!polynomial.<link linkend="_classemth_1_1Polynomial_1a1dc4825c3d5005949f0869e204e4fedc">push_monomial</link>(std::move(this-&gt;parse_monomial())))&#32;{<emphasis role="keywordflow">return</emphasis>&#32;polynomial;}}
<anchor xml:id="_src_2eparser_8cpp_source_1l00109"/>00109 }
<anchor xml:id="_src_2eparser_8cpp_source_1l00114"/><link linkend="_classemthp_1_1Parser_1a590566c3e893515a0dbb9db032a889cd">00114</link> <link linkend="_classemth_1_1Monomial">emth::Monomial</link>&#32;<link linkend="_classemthp_1_1Parser_1a590566c3e893515a0dbb9db032a889cd">emthp::Parser::parse_monomial</link>()&#32;noexcept&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00115"/>00115 &#32;&#32;&#32;&#32;<link linkend="_classemth_1_1Monomial">emth::Monomial</link>&#32;monomial(0,&#32;0);
<anchor xml:id="_src_2eparser_8cpp_source_1l00116"/>00116 &#32;&#32;&#32;&#32;monomial.<link linkend="_classemth_1_1Monomial_1adae9aaac815a7c86ec651e5bdb3d3043">set_coeff</link>(this-&gt;parse_number());
<anchor xml:id="_src_2eparser_8cpp_source_1l00117"/>00117 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;v&#32;=&#32;<emphasis role="keyword">false</emphasis>;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;e&#32;=&#32;<emphasis role="keyword">false</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00118"/>00118 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(!v&#32;||&#32;!e)&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00119"/>00119 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_structemthp_1_1Token">emthp::Token</link>&#32;token&#32;=&#32;this-&gt;_lexer.next();
<anchor xml:id="_src_2eparser_8cpp_source_1l00120"/>00120 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(token.<link linkend="_structemthp_1_1Token_1ae532928c40581bc20349979955dfb2f3">type</link>)&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00121"/>00121 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_VARIABLE:&#32;v&#32;=&#32;<emphasis role="keyword">true</emphasis>;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00122"/>00122 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_EXPONENT:&#32;<emphasis role="keywordflow">if</emphasis>&#32;(v)&#32;{e&#32;=&#32;<emphasis role="keyword">true</emphasis>;}&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00123"/>00123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;<link linkend="_namespaceemthp_1a29873cfffe66c1e0b36436ebcc54dc6bab0be00ab2ea8e4a56ab22f220c7de9bf">emthp::TokenType::T_PLUS</link>:&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_MINUS:&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_NUMBER:&#32;<emphasis role="keywordflow">if</emphasis>&#32;(v)&#32;{monomial.<link linkend="_classemth_1_1Monomial_1ab695cba07bcbf08cfec7d32e0bf4cc20">set_degree</link>(1);&#32;this-&gt;_lexer.back();}&#32;<emphasis role="keywordflow">return</emphasis>&#32;monomial;
<anchor xml:id="_src_2eparser_8cpp_source_1l00124"/>00124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_EOF:&#32;<emphasis role="keywordflow">if</emphasis>&#32;(v)&#32;{monomial.<link linkend="_classemth_1_1Monomial_1ab695cba07bcbf08cfec7d32e0bf4cc20">set_degree</link>(1);}&#32;<emphasis role="keywordflow">return</emphasis>&#32;monomial;
<anchor xml:id="_src_2eparser_8cpp_source_1l00125"/>00125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00126"/>00126 &#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00127"/>00127 &#32;&#32;&#32;&#32;monomial.<link linkend="_classemth_1_1Monomial_1ab695cba07bcbf08cfec7d32e0bf4cc20">set_degree</link>((<emphasis role="keywordtype">int</emphasis>)&#32;this-&gt;parse_number());
<anchor xml:id="_src_2eparser_8cpp_source_1l00128"/>00128 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;monomial;
<anchor xml:id="_src_2eparser_8cpp_source_1l00129"/>00129 }
<anchor xml:id="_src_2eparser_8cpp_source_1l00134"/>00134 <emphasis role="keywordtype">double</emphasis>&#32;emthp::Parser::parse_number()&#32;noexcept&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00135"/>00135 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;positive&#32;=&#32;<emphasis role="keyword">true</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00136"/>00136 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>(<emphasis role="keyword">true</emphasis>)&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00137"/>00137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_structemthp_1_1Token">emthp::Token</link>&#32;token&#32;=&#32;this-&gt;_lexer.next();
<anchor xml:id="_src_2eparser_8cpp_source_1l00138"/>00138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>(token.<link linkend="_structemthp_1_1Token_1ae532928c40581bc20349979955dfb2f3">type</link>)&#32;{
<anchor xml:id="_src_2eparser_8cpp_source_1l00139"/>00139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_MINUS:&#32;positive&#32;=&#32;!positive;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00140"/>00140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_NUMBER:&#32;<emphasis role="keywordflow">return</emphasis>&#32;positive&#32;?&#32;token.<link linkend="_structemthp_1_1Token_1a0512f6f4c2a7dcf724d582d971393c2c">value</link>&#32;:&#32;-token.<link linkend="_structemthp_1_1Token_1a0512f6f4c2a7dcf724d582d971393c2c">value</link>;
<anchor xml:id="_src_2eparser_8cpp_source_1l00141"/>00141 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_VARIABLE:&#32;this-&gt;_lexer.back();&#32;<emphasis role="keywordflow">return</emphasis>&#32;positive&#32;?&#32;1&#32;:&#32;-1;
<anchor xml:id="_src_2eparser_8cpp_source_1l00142"/>00142 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;emthp::TokenType::T_EOF:&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
<anchor xml:id="_src_2eparser_8cpp_source_1l00143"/>00143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00144"/>00144 &#32;&#32;&#32;&#32;}
<anchor xml:id="_src_2eparser_8cpp_source_1l00145"/>00145 }
</programlisting></section>
