{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment EMath++ }EMath++}
{\comment Generated by doxygen 1.9.6.}
{\creatim \yr2023\mo2\dy11\hr11\min30\sec26}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt EMath++}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sat Feb 11 2023 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
EMath++ Project\par \pard\plain 
{\tc \v EMath++ Project}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Introduction
\par}
{\tc\tcl2 \v Introduction}
This is a project that aims to provide some wrapper classes for algebraic mathematical concepts.\par
At the moment it includes the Monomial and Polynomial classes for general calculus. The library is currently in expansion.\par
Any feedback is much appreciated!\par}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
The project comes with a folder with some bash files that complete some Meson related tasks.\par
All bash files must be executed from the project's root directory to work properly.\par
To install the project, there is only need to execute two of them files.\par
Once installed just include the {\b emath.h} header file in your code and link it with its implementation.\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Step one: Setup the Project
\par}
{\tc\tcl3 \v Step one: Setup the Project}
To setup the Meson project run the setup.sh bash file: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid bash ./scripts/setup.sh\par
}
\par}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Step two: Install the Library
\par}
{\tc\tcl3 \v Step two: Install the Library}
To install the emath library run the install.sh bash file:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid bash ./scripts/install.sh\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
You will need a privileged user's credentials\par
}}\par}
\par}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Testing
\par}
{\tc\tcl2 \v Testing}
The project comes with some test files located in the test folder.\par
To test that the library code works properly run the following bash file: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid bash ./scripts/test.sh\par
}
 \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Test List{\tc \v Test List}\par \pard\plain 
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, Lexer)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Test lexer functionality with simple expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, CompoundLexer)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Test lexer functionality with compund expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, ArithmeticLexer)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Test lexer functionality with arithmetic expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, Variables)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Test parser functionality with monomial expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, Compound)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Test parser functionality with polynomial expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, Signs)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Test parser functionality with sign expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, Noise)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Test parser functionality with noise in the expressions  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b TEST_F}  ({\b EParserTest}, Edge)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Test parser edge cases \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b emth} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the emath library })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b emthp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the parser })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
emth::Arithmetic\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
emthp::Lexer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
emth::Monomial\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
emthp::Parser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
emth::Polynomial\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::Test
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
EParserTest\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
emthp::Token\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b emth::Arithmetic} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class with some functions for arithmetic math })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EParserTest} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that provides a test fixture for the test cases })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b emthp::Lexer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that works as a token supplier for the {\b Parser} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b emth::Monomial} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating monomials })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b emthp::Parser} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that wraps a std::string and parses it as a Monomial or as a Polynomial })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b emth::Polynomial} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating polynomials })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b emthp::Token} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct for representing a token as a type and a value })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b include/{\b emath.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main header file for the emath library })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/{\b eparser.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main header file for the equation parser })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b emath.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main source file for the mathematical equation operations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b eparser.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main implementation file for the equation parser })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b emath.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main test file of the emath library. It contains all the tests needed to assure that the library works properly })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b eparser.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main test file for the equation parser })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emth Namespace Reference\par \pard\plain 
{\tc\tcl2 \v emth}
{\xe \v emth}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the emath library. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Arithmetic}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class with some functions for arithmetic math. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Monomial}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating monomials. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Polynomial}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating polynomials. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the emath library. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The emth namespace contains three classes: {\b Arithmetic}, {\b Monomial} and {\b Polynomial}. The first contains functions for arithmetic operations. The last two are wrappers on abstract algebraic concepts. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emthp Namespace Reference\par \pard\plain 
{\tc\tcl2 \v emthp}
{\xe \v emthp}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the parser. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Lexer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that works as a token supplier for the {\b Parser} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Parser}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that wraps a std::string and parses it as a Monomial or as a Polynomial. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Token}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct for representing a token as a type and a value. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TokenType} \{ {\b T_PLUS}
, {\b T_MINUS}
, {\b T_NUMBER}
, {\b T_VARIABLE}
, {\b T_EXPONENT}
, {\b T_EOF}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum with all the possible Token types. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the parser. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The emthp namespace contains two classes: {\b Parser} and {\b Lexer}. It also contains the TokenType enum and a {\b Token} struct. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v TokenType\:emthp}
{\xe \v emthp\:TokenType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b emthp::TokenType}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum with all the possible {\b Token} types. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v T_PLUS\:emthp}
{\xe \v emthp\:T_PLUS}
{\qr T_PLUS{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum with all the possible {\b Token} types. \par
}\cell }{\row }
}
{
Definition at line {\b 21} of file {\b eparser.h}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emth::Arithmetic Class Reference\par \pard\plain 
{\tc\tcl2 \v emth::Arithmetic}
{\xe \v emth::Arithmetic}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class with some functions for arithmetic math. }}\par
{
{\f2 #include <emath.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b get_divisors} (int n, std::vector< int > &v) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the all the positive divisors for an integer. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class with some functions for arithmetic math. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class consists of the functions that operate with real numbers. \par
}{
Definition at line {\b 67} of file {\b emath.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_divisors\:emth::Arithmetic}
{\xe \v emth::Arithmetic\:get_divisors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void emth::Arithmetic::get_divisors (int  {\i n}, std::vector< int > &  {\i v}){\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the all the positive divisors for an integer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n} \cell }{The integer to get the divisors for. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v} \cell }{The vector reference where to store the divisors. \cell }
{\row }
}
}{
Definition at line {\b 15} of file {\b emath.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b emath.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b emath.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EParserTest Class Reference\par \pard\plain 
{\tc\tcl2 \v EParserTest}
{\xe \v EParserTest}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that provides a test fixture for the test cases. }}\par
Inheritance diagram for EParserTest:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classEParserTest__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for EParserTest:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classEParserTest__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EParserTest} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standalone constructor for the {\b EParserTest} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_input} (const std::string &input)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function for setting the input to the lexer and parser objects. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b emthp::Lexer} {\b lexer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lexer object on which to perform the tests on. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b emthp::Parser} {\b parser}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parser object on which to perform the tests on. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that provides a test fixture for the test cases. \par
}{
Definition at line {\b 14} of file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EParserTest\:EParserTest}
{\xe \v EParserTest\:EParserTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EParserTest::EParserTest (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standalone constructor for the {\b EParserTest} class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the lexer and parser object with empty inputs. \par
}{
Definition at line {\b 20} of file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v set_input\:EParserTest}
{\xe \v EParserTest\:set_input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EParserTest::set_input (const std::string &  {\i input}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function for setting the input to the lexer and parser objects. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i input} \cell }{The std::string to set as input \cell }
{\row }
}
}{
Definition at line {\b 25} of file {\b eparser.cpp}.}\par
{
\ql
References {\b lexer}, and {\b parser}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v lexer\:EParserTest}
{\xe \v EParserTest\:lexer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emthp::Lexer} EParserTest::lexer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lexer object on which to perform the tests on. }}\par
{
Definition at line {\b 33} of file {\b eparser.cpp}.}\par
}
{\xe \v parser\:EParserTest}
{\xe \v EParserTest\:parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emthp::Parser} EParserTest::parser{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parser object on which to perform the tests on. }}\par
{
Definition at line {\b 37} of file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b eparser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emthp::Lexer Class Reference\par \pard\plain 
{\tc\tcl2 \v emthp::Lexer}
{\xe \v emthp::Lexer}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that works as a token supplier for the {\b Parser} class. }}\par
{
{\f2 #include <eparser.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Lexer} (const std::string &input) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standalone constructor for the {\b Lexer} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Lexer} & {\b operator=} (const {\b Lexer} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator for when called with an lvalue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Token} {\b next} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that returns the next {\b Token} in the input provided in the constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b back} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backtrack function that moves the cursor's position one position backwards. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that works as a token supplier for the {\b Parser} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class consists of two public functions, one for getting the next {\b Token} and the other for going back one position. \par
}{
Definition at line {\b 52} of file {\b eparser.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Lexer\:emthp::Lexer}
{\xe \v emthp::Lexer\:Lexer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emthp::Lexer::Lexer (const std::string &  {\i input}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standalone constructor for the {\b Lexer} class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i input} \cell }{A const reference to the std::string to tokenize. \cell }
{\row }
}
}{
Definition at line {\b 14} of file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v back\:emthp::Lexer}
{\xe \v emthp::Lexer\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void emthp::Lexer::back (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backtrack function that moves the cursor's position one position backwards. }}\par
{
Definition at line {\b 52} of file {\b eparser.cpp}.}\par
}
{\xe \v next\:emthp::Lexer}
{\xe \v emthp::Lexer\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emthp::Token} emthp::Lexer::next (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that returns the next {\b Token} in the input provided in the constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Token}) The next {\b Token} in the input \par
}}}{
Definition at line {\b 29} of file {\b eparser.cpp}.}\par
{
\ql
References {\b next()}, and {\b emthp::T_PLUS}.}\par
}
{\xe \v operator=\:emthp::Lexer}
{\xe \v emthp::Lexer\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emthp::Lexer} & emthp::Lexer::operator= (const {\b Lexer} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator for when called with an lvalue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The lvalue {\b Lexer} object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Lexer}&) A reference to the lvalue of the operation \par
}}}{
Definition at line {\b 20} of file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b eparser.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b eparser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emth::Monomial Class Reference\par \pard\plain 
{\tc\tcl2 \v emth::Monomial}
{\xe \v emth::Monomial}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating monomials. }}\par
{
{\f2 #include <emath.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for when initialized with no arguments. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} (const double cf, const int dgr) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal constructor for initialization with coeff and degree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor for when initialized with an lvalue {\b Monomial} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} ({\b Monomial} &&ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor for when initialized with an rvalue {\b Monomial} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator=} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator overload for when called with an lvalue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator=} ({\b Monomial} &&ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move assigment operator overload for when called with an rvalue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equal logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not equal logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater or equal than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less or equal than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} {\b operator+} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} {\b operator-} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} {\b operator*} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} {\b operator/} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} {\b operator%} (const {\b Monomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator+=} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator-=} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator*=} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator/=} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Monomial} & {\b operator%=} (const {\b Monomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b get_coeff} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the coefficient of the {\b Monomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_degree} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the degree of the {\b Monomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_coeff} (double cf) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setter function for setting the coefficient of the {\b Monomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_degree} (int dgr) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setter function for setting the degree of the {\b Monomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b get_expression} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the expression of the {\b Monomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b get_value} (const double &x) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the value of the {\b Monomial} at a point. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~Monomial} (){\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class destructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::stringstream & {\b operator<<} (std::stringstream &ss, const {\b Monomial} &m)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Monomial} into a std::stringstream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &out, const {\b Monomial} &m)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Monomial} into a std::ostream. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating monomials. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class consists of the constructors, the operators, the getters, the properties and some private functions. \par
}{
Definition at line {\b 81} of file {\b emath.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Monomial\:emth::Monomial}
{\xe \v emth::Monomial\:Monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Monomial::Monomial (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for when initialized with no arguments. }}\par
{
Definition at line {\b 30} of file {\b emath.cpp}.}\par
}
{\xe \v Monomial\:emth::Monomial}
{\xe \v emth::Monomial\:Monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Monomial::Monomial (const double  {\i cf}, const int  {\i dgr}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal constructor for initialization with coeff and degree. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cf} \cell }{The coefficient as a double. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dgr} \cell }{The degree as a integer. \cell }
{\row }
}
}{
Definition at line {\b 36} of file {\b emath.cpp}.}\par
}
{\xe \v Monomial\:emth::Monomial}
{\xe \v emth::Monomial\:Monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Monomial::Monomial (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor for when initialized with an lvalue {\b Monomial} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The lvalue {\b Monomial} object. \cell }
{\row }
}
}{
Definition at line {\b 41} of file {\b emath.cpp}.}\par
}
{\xe \v Monomial\:emth::Monomial}
{\xe \v emth::Monomial\:Monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Monomial::Monomial ({\b Monomial} &&  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor for when initialized with an rvalue {\b Monomial} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The rvalue {\b Monomial} object. \cell }
{\row }
}
}{
Definition at line {\b 46} of file {\b emath.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_coeff\:emth::Monomial}
{\xe \v emth::Monomial\:get_coeff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double emth::Monomial::get_coeff () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the coefficient of the {\b Monomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(double) The coefficient of the {\b Monomial}. \par
}}}{
Definition at line {\b 207} of file {\b emath.cpp}.}\par
}
{\xe \v get_degree\:emth::Monomial}
{\xe \v emth::Monomial\:get_degree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int emth::Monomial::get_degree () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the degree of the {\b Monomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(int) The degree of the {\b Monomial}. \par
}}}{
Definition at line {\b 212} of file {\b emath.cpp}.}\par
}
{\xe \v get_expression\:emth::Monomial}
{\xe \v emth::Monomial\:get_expression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string emth::Monomial::get_expression () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the expression of the {\b Monomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::string) The expression of the {\b Monomial}. \par
}}}{
Definition at line {\b 227} of file {\b emath.cpp}.}\par
}
{\xe \v get_value\:emth::Monomial}
{\xe \v emth::Monomial\:get_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double emth::Monomial::get_value (const double &  {\i x}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the value of the {\b Monomial} at a point. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{The point to evaluate. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(double) The result of the evaluation of the {\b Monomial}. \par
}}}{
Definition at line {\b 233} of file {\b emath.cpp}.}\par
}
{\xe \v operator!=\:emth::Monomial}
{\xe \v emth::Monomial\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Monomial::operator!= (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not equal logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If {\b Monomial} objects coefficients and degrees dont match. \par
(false) If {\b Monomial} objects coefficients and degrees match. \par
}}}{
Definition at line {\b 72} of file {\b emath.cpp}.}\par
}
{\xe \v operator%\:emth::Monomial}
{\xe \v emth::Monomial\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} emth::Monomial::operator% (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}) A brand new {\b Monomial} that represents the result. \par
}}}{
Definition at line {\b 130} of file {\b emath.cpp}.}\par
}
{\xe \v operator%=\:emth::Monomial}
{\xe \v emth::Monomial\:operator%=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator%= (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 182} of file {\b emath.cpp}.}\par
}
{\xe \v operator*\:emth::Monomial}
{\xe \v emth::Monomial\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} emth::Monomial::operator* (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to multiply by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}) A brand new {\b Monomial} that represents the result. \par
}}}{
Definition at line {\b 118} of file {\b emath.cpp}.}\par
}
{\xe \v operator*=\:emth::Monomial}
{\xe \v emth::Monomial\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator*= (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to multiply by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 160} of file {\b emath.cpp}.}\par
}
{\xe \v operator+\:emth::Monomial}
{\xe \v emth::Monomial\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} emth::Monomial::operator+ (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to add. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}) A brand new {\b Monomial} that represents the result. \par
}}}{
Definition at line {\b 106} of file {\b emath.cpp}.}\par
}
{\xe \v operator+=\:emth::Monomial}
{\xe \v emth::Monomial\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator+= (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to add. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 136} of file {\b emath.cpp}.}\par
}
{\xe \v operator-\:emth::Monomial}
{\xe \v emth::Monomial\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} emth::Monomial::operator- (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to substract by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}) A brand new {\b Monomial} that represents the result. \par
}}}{
Definition at line {\b 112} of file {\b emath.cpp}.}\par
}
{\xe \v operator-=\:emth::Monomial}
{\xe \v emth::Monomial\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator-= (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to substract by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 148} of file {\b emath.cpp}.}\par
}
{\xe \v operator/\:emth::Monomial}
{\xe \v emth::Monomial\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} emth::Monomial::operator/ (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}) A brand new {\b Monomial} that represents the result. \par
}}}{
Definition at line {\b 124} of file {\b emath.cpp}.}\par
}
{\xe \v operator/=\:emth::Monomial}
{\xe \v emth::Monomial\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator/= (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 170} of file {\b emath.cpp}.}\par
}
{\xe \v operator<\:emth::Monomial}
{\xe \v emth::Monomial\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Monomial::operator< (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Monomial} object degree is less than the degree of the passed {\b Monomial}. \par
(false) If the {\b Monomial} object degree is equal or greater than the degree of the passed {\b Monomial}. \par
}}}{
Definition at line {\b 86} of file {\b emath.cpp}.}\par
}
{\xe \v operator<=\:emth::Monomial}
{\xe \v emth::Monomial\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Monomial::operator<= (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less or equal than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Monomial} object degree is less or equal than the degree of the passed {\b Monomial}. \par
(false) If the {\b Monomial} object degree is greater than the degree of the passed {\b Monomial}. \par
}}}{
Definition at line {\b 100} of file {\b emath.cpp}.}\par
}
{\xe \v operator=\:emth::Monomial}
{\xe \v emth::Monomial\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator= (const {\b Monomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator overload for when called with an lvalue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The lvalue {\b Monomial} object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation \par
}}}{
Definition at line {\b 52} of file {\b emath.cpp}.}\par
}
{\xe \v operator=\:emth::Monomial}
{\xe \v emth::Monomial\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} & emth::Monomial::operator= ({\b emth::Monomial} &&  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move assigment operator overload for when called with an rvalue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The rvalue {\b Monomial} object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Monomial}&) A reference to the lvalue of the operation \par
}}}{
Definition at line {\b 58} of file {\b emath.cpp}.}\par
}
{\xe \v operator==\:emth::Monomial}
{\xe \v emth::Monomial\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Monomial::operator== (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equal logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If {\b Monomial} objects coefficients and degrees match. \par
(false) If {\b Monomial} objects coefficients and degrees dont match. \par
}}}{
Definition at line {\b 65} of file {\b emath.cpp}.}\par
}
{\xe \v operator>\:emth::Monomial}
{\xe \v emth::Monomial\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Monomial::operator> (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Monomial} object degree is greater than the degree of the passed {\b Monomial}. \par
(false) If the {\b Monomial} object degree is equal or less than the degree of the passed {\b Monomial}. \par
}}}{
Definition at line {\b 79} of file {\b emath.cpp}.}\par
}
{\xe \v operator>=\:emth::Monomial}
{\xe \v emth::Monomial\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Monomial::operator>= (const {\b Monomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater or equal than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Monomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Monomial} object degree is greater or equal than the degree of the passed {\b Monomial}. \par
(false) If the {\b Monomial} object degree is less than the degree of the passed {\b Monomial}. \par
}}}{
Definition at line {\b 93} of file {\b emath.cpp}.}\par
}
{\xe \v set_coeff\:emth::Monomial}
{\xe \v emth::Monomial\:set_coeff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void emth::Monomial::set_coeff (double  {\i cf}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setter function for setting the coefficient of the {\b Monomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cf} \cell }{The coefficient to set to. \cell }
{\row }
}
}{
Definition at line {\b 217} of file {\b emath.cpp}.}\par
}
{\xe \v set_degree\:emth::Monomial}
{\xe \v emth::Monomial\:set_degree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void emth::Monomial::set_degree (int  {\i dgr}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setter function for setting the degree of the {\b Monomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dgr} \cell }{The degree to set to. \cell }
{\row }
}
}{
Definition at line {\b 222} of file {\b emath.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:emth::Monomial}
{\xe \v emth::Monomial\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i out}, const {\b Monomial} &  {\i m}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Monomial} into a std::ostream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out} \cell }{The std::ostream. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i m} \cell }{The {\b Monomial} object to insert. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::ostream&) A reference to the std::ostream. \par
}}}}
{\xe \v operator<<\:emth::Monomial}
{\xe \v emth::Monomial\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::stringstream & operator<< (std::stringstream &  {\i ss}, const {\b Monomial} &  {\i m}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Monomial} into a std::stringstream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ss} \cell }{The std::stringstream. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i m} \cell }{The {\b Monomial} object to insert. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::stringstream&) A reference to the std::stringstream. \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b emath.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b emath.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emthp::Parser Class Reference\par \pard\plain 
{\tc\tcl2 \v emthp::Parser}
{\xe \v emthp::Parser}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that wraps a std::string and parses it as a Monomial or as a Polynomial. }}\par
{
{\f2 #include <eparser.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} (const std::string &input) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standalone constructor for the {\b Parser} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} & {\b operator=} (const {\b Parser} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator for when called with an lvalue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b emth::Polynomial} {\b parse_polynomial} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that parses the input as a Polynomial. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b emth::Monomial} {\b parse_monomial} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that parses the next Monomial in the input. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that wraps a std::string and parses it as a Monomial or as a Polynomial. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class consists of two public functions, one for parsing the entire input as a Polynomial and the other for parsing only the next Monomial. \par
}{
Definition at line {\b 107} of file {\b eparser.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Parser\:emthp::Parser}
{\xe \v emthp::Parser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emthp::Parser::Parser (const std::string &  {\i input}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standalone constructor for the {\b Parser} class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i input} \cell }{A const reference to the std::string to parse when needed. \cell }
{\row }
}
}{
Definition at line {\b 95} of file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:emthp::Parser}
{\xe \v emthp::Parser\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emthp::Parser} & emthp::Parser::operator= (const {\b Parser} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator for when called with an lvalue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The lvalue {\b Parser} object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Parser}&) A reference to the lvalue of the operation \par
}}}{
Definition at line {\b 101} of file {\b eparser.cpp}.}\par
}
{\xe \v parse_monomial\:emthp::Parser}
{\xe \v emthp::Parser\:parse_monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Monomial} emthp::Parser::parse_monomial (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that parses the next Monomial in the input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b emth::Monomial}) The next Monomial in the input \par
}}}{
Definition at line {\b 114} of file {\b eparser.cpp}.}\par
{
\ql
References {\b emth::Monomial::set_coeff()}, {\b emth::Monomial::set_degree()}, {\b emthp::T_PLUS}, and {\b emthp::Token::type}.}\par
}
{\xe \v parse_polynomial\:emthp::Parser}
{\xe \v emthp::Parser\:parse_polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emthp::Parser::parse_polynomial (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that parses the input as a Polynomial. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b emth::Polynomial}) The input as a Polynomial \par
}}}{
Definition at line {\b 106} of file {\b eparser.cpp}.}\par
{
\ql
References {\b emth::Polynomial::push_monomial()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b eparser.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b eparser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emth::Polynomial Class Reference\par \pard\plain 
{\tc\tcl2 \v emth::Polynomial}
{\xe \v emth::Polynomial}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating polynomials. }}\par
{
{\f2 #include <emath.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for when initialized with no arguments. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} (const std::map< int, {\b Monomial} > mns) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal constructor for initialization with a std::map<int, Monomial> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} (const std::initializer_list< {\b Monomial} > mns) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List constructor for initialization with a std::initializer_list<Monomial> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} (const std::vector< {\b Monomial} > mns) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector constructor for initialization with a std::vector<Monomial> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor for when initialized with an lvalue {\b Polynomial} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} ({\b Polynomial} &&ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor for when initialized with an rvalue {\b Polynomial} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator=} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator overload for when called with an lvalue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator=} ({\b Polynomial} &&ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move assigment operator overload for when called with an rvalue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equal logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not equal logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater or equal than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less or equal than logic operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b operator+} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b operator-} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b operator*} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b operator/} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b operator%} (const {\b Polynomial} &ogn) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator+=} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator-=} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator*=} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator/=} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} & {\b operator%=} (const {\b Polynomial} &ogn) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus assigment operator overload. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_degree} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the degree of the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< int, {\b Monomial} > {\b get_monomials} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the monomials of the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b push_monomial} (const {\b Monomial} &m) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function for appending a lvalue monomial to the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b push_monomial} ({\b Monomial} &&m) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function for appending a rvalue monomial to the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b get_expression} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the expression of the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b get_value} (const double &x) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the value of the {\b Polynomial} at a point. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b get_derivative} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the derivative of the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Polynomial} {\b get_integral} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the integral of the {\b Polynomial}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~Polynomial} (){\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class destructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::stringstream & {\b operator<<} (std::stringstream &ss, const {\b Polynomial} &p) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Polynomial} into a std::stringstream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &out, const {\b Polynomial} &p) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Polynomial} into a std::ostream. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating polynomials. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class consists of the constructors, the operators, the getters, the properties and some private functions. \par
}{
Definition at line {\b 286} of file {\b emath.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Polynomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:Polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Polynomial::Polynomial (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for when initialized with no arguments. }}\par
{
Definition at line {\b 250} of file {\b emath.cpp}.}\par
}
{\xe \v Polynomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:Polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Polynomial::Polynomial (const std::map< int, {\b Monomial} >  {\i mns}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal constructor for initialization with a std::map<int, Monomial> }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mns} \cell }{The std::map<int, Monomial>. \cell }
{\row }
}
}}
{\xe \v Polynomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:Polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Polynomial::Polynomial (const std::initializer_list< {\b Monomial} >  {\i mns}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List constructor for initialization with a std::initializer_list<Monomial> }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mns} \cell }{The std::initializer_list<Monomial>. \cell }
{\row }
}
}}
{\xe \v Polynomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:Polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Polynomial::Polynomial (const std::vector< {\b Monomial} >  {\i mns}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector constructor for initialization with a std::vector<Monomial> }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mns} \cell }{The std::vector<Monomial>. \cell }
{\row }
}
}}
{\xe \v Polynomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:Polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Polynomial::Polynomial (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor for when initialized with an lvalue {\b Polynomial} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The lvalue {\b Polynomial} object. \cell }
{\row }
}
}{
Definition at line {\b 270} of file {\b emath.cpp}.}\par
}
{\xe \v Polynomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:Polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
emth::Polynomial::Polynomial ({\b emth::Polynomial} &&  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor for when initialized with an rvalue {\b Polynomial} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The rvalue {\b Polynomial} object. \cell }
{\row }
}
}{
Definition at line {\b 275} of file {\b emath.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_degree\:emth::Polynomial}
{\xe \v emth::Polynomial\:get_degree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int emth::Polynomial::get_degree () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the degree of the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(int) The degree of the {\b Polynomial}. \par
}}}{
Definition at line {\b 448} of file {\b emath.cpp}.}\par
}
{\xe \v get_derivative\:emth::Polynomial}
{\xe \v emth::Polynomial\:get_derivative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::get_derivative () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the derivative of the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) The result of the derivative of the {\b Polynomial}. \par
}}}{
Definition at line {\b 490} of file {\b emath.cpp}.}\par
}
{\xe \v get_expression\:emth::Polynomial}
{\xe \v emth::Polynomial\:get_expression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string emth::Polynomial::get_expression () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the expression of the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::string) The expression of the {\b Polynomial}. \par
}}}{
Definition at line {\b 475} of file {\b emath.cpp}.}\par
}
{\xe \v get_integral\:emth::Polynomial}
{\xe \v emth::Polynomial\:get_integral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::get_integral () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the integral of the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) The result of the integral of the {\b Polynomial}. \par
}}}{
Definition at line {\b 501} of file {\b emath.cpp}.}\par
}
{\xe \v get_monomials\:emth::Polynomial}
{\xe \v emth::Polynomial\:get_monomials}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map< int, {\b emth::Monomial} > emth::Polynomial::get_monomials () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getter function for getting the monomials of the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::map<int, Monomial>) The monomials of the {\b Polynomial}. \par
}}}{
Definition at line {\b 453} of file {\b emath.cpp}.}\par
}
{\xe \v get_value\:emth::Polynomial}
{\xe \v emth::Polynomial\:get_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double emth::Polynomial::get_value (const double &  {\i x}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculus function for getting the value of the {\b Polynomial} at a point. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{The point to evaluate. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(double) The result of the evaluation of the {\b Polynomial}. \par
}}}{
Definition at line {\b 481} of file {\b emath.cpp}.}\par
}
{\xe \v operator!=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::operator!= (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not equal logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If {\b Polynomial} objects degrees and monomials dont match. \par
(false) If {\b Polynomial} objects degrees and monomials match. \par
}}}{
Definition at line {\b 301} of file {\b emath.cpp}.}\par
}
{\xe \v operator%\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::operator% (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) A brand new {\b Polynomial} that represents the result. \par
}}}{
Definition at line {\b 359} of file {\b emath.cpp}.}\par
}
{\xe \v operator%=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator%=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator%= (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulus assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 415} of file {\b emath.cpp}.}\par
}
{\xe \v operator*\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::operator* (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to multiply by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) A brand new {\b Polynomial} that represents the result. \par
}}}{
Definition at line {\b 347} of file {\b emath.cpp}.}\par
}
{\xe \v operator*=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator*= (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to multiply by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 383} of file {\b emath.cpp}.}\par
}
{\xe \v operator+\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::operator+ (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to add. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) A brand new {\b Polynomial} that represents the result. \par
}}}{
Definition at line {\b 335} of file {\b emath.cpp}.}\par
}
{\xe \v operator+=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator+= (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to add. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 365} of file {\b emath.cpp}.}\par
}
{\xe \v operator-\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::operator- (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to substract by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) A brand new {\b Polynomial} that represents the result. \par
}}}{
Definition at line {\b 341} of file {\b emath.cpp}.}\par
}
{\xe \v operator-=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator-= (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Substraction assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to substract by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 374} of file {\b emath.cpp}.}\par
}
{\xe \v operator/\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} emth::Polynomial::operator/ (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}) A brand new {\b Polynomial} that represents the result. \par
}}}{
Definition at line {\b 353} of file {\b emath.cpp}.}\par
}
{\xe \v operator/=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator/= (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Division assigment operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to divide by. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation. \par
}}}{
Definition at line {\b 398} of file {\b emath.cpp}.}\par
{
\ql
References {\b emth::Monomial::get_degree()}.}\par
}
{\xe \v operator<\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::operator< (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Polynomial} object degree is less than the degree of the passed {\b Polynomial}. \par
(false) If the {\b Polynomial} object degree is equal or greater than the degree of the passed {\b Polynomial}. \par
}}}{
Definition at line {\b 315} of file {\b emath.cpp}.}\par
}
{\xe \v operator<=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::operator<= (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less or equal than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Polynomial} object degree is less or equal than the degree of the passed {\b Polynomial}. \par
(false) If the {\b Polynomial} object degree is greater than the degree of the passed {\b Polynomial}. \par
}}}{
Definition at line {\b 329} of file {\b emath.cpp}.}\par
}
{\xe \v operator=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator= (const {\b Polynomial} &  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigment operator overload for when called with an lvalue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The lvalue {\b Polynomial} object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation \par
}}}{
Definition at line {\b 281} of file {\b emath.cpp}.}\par
}
{\xe \v operator=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b emth::Polynomial} & emth::Polynomial::operator= ({\b emth::Polynomial} &&  {\i ogn}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move assigment operator overload for when called with an rvalue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The rvalue {\b Polynomial} object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
({\b Polynomial}&) A reference to the lvalue of the operation \par
}}}{
Definition at line {\b 287} of file {\b emath.cpp}.}\par
}
{\xe \v operator==\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::operator== (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equal logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If {\b Polynomial} objects degrees and monomials match. \par
(false) If {\b Polynomial} objects degrees and monomials dont match. \par
}}}{
Definition at line {\b 294} of file {\b emath.cpp}.}\par
}
{\xe \v operator>\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::operator> (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Polynomial} object degree is greater than the degree of the passed {\b Polynomial}. \par
(false) If the {\b Polynomial} object degree is equal or less than the degree of the passed {\b Polynomial}. \par
}}}{
Definition at line {\b 308} of file {\b emath.cpp}.}\par
}
{\xe \v operator>=\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::operator>= (const {\b Polynomial} &  {\i ogn}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Greater or equal than logic operator overload. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ogn} \cell }{The {\b Polynomial} object to compare to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(true) If the {\b Polynomial} object degree is greater or equal than the degree of the passed {\b Polynomial}. \par
(false) If the {\b Polynomial} object degree is less than the degree of the passed {\b Polynomial}. \par
}}}{
Definition at line {\b 322} of file {\b emath.cpp}.}\par
}
{\xe \v push_monomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:push_monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::push_monomial (const {\b Monomial} &  {\i m}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function for appending a lvalue monomial to the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i m} \cell }{The {\b Monomial} object to append. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(bool) If the operation was successful. \par
}}}{
Definition at line {\b 459} of file {\b emath.cpp}.}\par
}
{\xe \v push_monomial\:emth::Polynomial}
{\xe \v emth::Polynomial\:push_monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool emth::Polynomial::push_monomial ({\b emth::Monomial} &&  {\i m}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function for appending a rvalue monomial to the {\b Polynomial}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i m} \cell }{The {\b Monomial} object to append. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(bool) If the operation was successful. \par
}}}{
Definition at line {\b 465} of file {\b emath.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i out}, const {\b Polynomial} &  {\i p}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Polynomial} into a std::ostream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out} \cell }{The std::ostream. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i m} \cell }{The {\b Polynomial} object to insert. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::ostream&) A reference to the std::ostream. \par
}}}}
{\xe \v operator<<\:emth::Polynomial}
{\xe \v emth::Polynomial\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::stringstream & operator<< (std::stringstream &  {\i ss}, const {\b Polynomial} &  {\i p}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A friend operator to insert the {\b Polynomial} into a std::stringstream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ss} \cell }{The std::stringstream. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i m} \cell }{The {\b Polynomial} object to insert. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(std::stringstream&) A reference to the std::stringstream. \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b emath.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b emath.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emthp::Token Struct Reference\par \pard\plain 
{\tc\tcl2 \v emthp::Token}
{\xe \v emthp::Token}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct for representing a token as a type and a value. }}\par
{
{\f2 #include <eparser.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenType} {\b type}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The token's type as a TokenType. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b value}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The token's numerical value as a double. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct for representing a token as a type and a value. \par
}{
Definition at line {\b 36} of file {\b eparser.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v type\:emthp::Token}
{\xe \v emthp::Token\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TokenType} emthp::Token::type}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The token's type as a TokenType. }}\par
{
Definition at line {\b 41} of file {\b eparser.h}.}\par
}
{\xe \v value\:emthp::Token}
{\xe \v emthp::Token\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double emthp::Token::value}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The token's numerical value as a double. }}\par
{
Definition at line {\b 45} of file {\b eparser.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b eparser.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/emath.h File Reference\par \pard\plain 
{\tc\tcl2 \v include/emath.h}
{\xe \v include/emath.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main header file for the emath library. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <map>}\par
{\f2 #include <cmath>}\par
{\f2 #include <complex>}\par
{\f2 #include <vector>}\par
{\f2 #include <string>}\par
{\f2 #include <set.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for emath.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "emath_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "emath_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b emth::Arithmetic}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class with some functions for arithmetic math. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b emth::Monomial}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating monomials. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b emth::Polynomial}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for representing and operating polynomials. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b emth}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the emath library. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main header file for the emath library. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file declares the functions of the emath library.\par
It consists of two classes, the Monomial class and the Polynomial class.\par
The Monomial class declares all the functions, operators, and properties for representing and operating monomials.\par
The Polynomial class declares all the functions, operators, and properties for representing and operating polynomials.\par
}{
Definition in file {\b emath.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emath.h\par \pard\plain 
{\tc\tcl2 \v include/emath.h}
{\xe \v include/emath.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00050 {\cf21 #include <map>}\par
00051 {\cf21 #include <cmath>}\par
00052 {\cf21 #include <complex>}\par
00053 {\cf21 #include <vector>}\par
00054 {\cf21 #include <string>}\par
00055 {\cf21 #include <set.h>}\par
00061 {\cf17 namespace }emth \{\par
00067     {\cf17 class }Arithmetic \{\par
00068         {\cf17 public}:\par
00074             {\cf17 static} {\cf18 void} get_divisors({\cf18 int} n, std::vector<int>& v) {\cf17 noexcept};\par
00075     \};\par
00081     {\cf17 class }Monomial \{\par
00082         {\cf17 public}:\par
00086             Monomial() {\cf17 noexcept}; {\cf20 //Default constructor}\par
00092 {\cf20 }            Monomial({\cf17 const} {\cf18 double} cf, {\cf17 const} {\cf18 int} dgr) {\cf17 noexcept}; {\cf20 //Constructor}\par
00097 {\cf20 }            Monomial({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Copy constructor}\par
00102 {\cf20 }            Monomial(Monomial&& ogn) {\cf17 noexcept}; {\cf20 //Move constructor}\par
00108 {\cf20 }            Monomial& operator =({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Assigment operator}\par
00114 {\cf20 }            Monomial& operator =(Monomial&& ogn) {\cf17 noexcept}; {\cf20 //Move assigment operator}\par
00121 {\cf20 }            {\cf18 bool} operator ==({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Equal logic operator}\par
00128 {\cf20 }            {\cf18 bool} operator !=({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Not Equal logic operator}\par
00135 {\cf20 }            {\cf18 bool} operator >({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Greater than logic operator}\par
00142 {\cf20 }            {\cf18 bool} operator <({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Less than logic operator}\par
00149 {\cf20 }            {\cf18 bool} operator >=({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Greater or Equal than logic operator}\par
00156 {\cf20 }            {\cf18 bool} operator <=({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Less or Equal than logic operator}\par
00162 {\cf20 }            Monomial operator +({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Addition operator}\par
00168 {\cf20 }            Monomial operator -({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Substraction operator}\par
00174 {\cf20 }            Monomial operator *({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Multiplication operator}\par
00180 {\cf20 }            Monomial operator /({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Division operator}\par
00186 {\cf20 }            Monomial operator %({\cf17 const} Monomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Modulus operator}\par
00192 {\cf20 }            Monomial& operator +=({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Addition assigment operator}\par
00198 {\cf20 }            Monomial& operator -=({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Substraction assigment operator}\par
00204 {\cf20 }            Monomial& operator *=({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Multiplication assigment operator}\par
00210 {\cf20 }            Monomial& operator /=({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Division assigment operator}\par
00216 {\cf20 }            Monomial& operator %=({\cf17 const} Monomial& ogn) {\cf17 noexcept}; {\cf20 //Modulus assigment operator}\par
00223 {\cf20 }            {\cf17 friend} std::stringstream& operator<<(std::stringstream& ss, {\cf17 const} Monomial& m); {\cf20 //Stream operator}\par
00230 {\cf20 }            {\cf17 friend} std::ostream& operator<<(std::ostream& out, {\cf17 const} Monomial& m); {\cf20 //Stream operator}\par
00235 {\cf20 }            {\cf18 double} get_coeff() const noexcept; {\cf20 //Coefficient getter}\par
00240 {\cf20 }            {\cf18 int} get_degree() const noexcept; {\cf20 //Degree getter}\par
00245 {\cf20 }            {\cf18 void} set_coeff({\cf18 double} cf) noexcept; {\cf20 //Coefficient setter}\par
00250 {\cf20 }            {\cf18 void} set_degree({\cf18 int} dgr) noexcept; {\cf20 //Degree setter}\par
00255 {\cf20 }            std::{\cf18 string} get_expression() const noexcept; {\cf20 //String expression getter}\par
00261 {\cf20 }            {\cf18 double} get_value(const {\cf18 double}& x) const noexcept; {\cf20 //Value for x getter}\par
00265 {\cf20 }            ~Monomial(); {\cf20 //Destructor}\par
00266         private:\par
00270             {\cf18 double} coeff;\par
00274             {\cf18 int} degree;\par
00279             {\cf18 void} swap(Monomial& ogn) noexcept; {\cf20 //Swap function}\par
00280     \};\par
00286     class Polynomial \{\par
00287         {\cf17 public}:\par
00291             Polynomial() {\cf17 noexcept}; {\cf20 //Default constructor}\par
00296 {\cf20 }            Polynomial({\cf17 const} std::map<int, Monomial> mns) {\cf17 noexcept}; {\cf20 //Constructor}\par
00301 {\cf20 }            Polynomial({\cf17 const} std::initializer_list<Monomial> mns) {\cf17 noexcept}; {\cf20 //List Constructor}\par
00306 {\cf20 }            Polynomial({\cf17 const} std::vector<Monomial> mns) {\cf17 noexcept}; {\cf20 //Vector Constructor}\par
00311 {\cf20 }            Polynomial({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Copy constructor}\par
00316 {\cf20 }            Polynomial(Polynomial&& ogn) {\cf17 noexcept}; {\cf20 //Move constructor}\par
00322 {\cf20 }            Polynomial& operator =({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Assigment operator}\par
00328 {\cf20 }            Polynomial& operator =(Polynomial&& ogn) {\cf17 noexcept}; {\cf20 //Move assigment operator}\par
00335 {\cf20 }            {\cf18 bool} operator ==({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Equal logic operator}\par
00342 {\cf20 }            {\cf18 bool} operator !=({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Not equal logic operator}\par
00349 {\cf20 }            {\cf18 bool} operator >({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Greater than logic operator}\par
00356 {\cf20 }            {\cf18 bool} operator <({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Lesser than logic operator}\par
00363 {\cf20 }            {\cf18 bool} operator >=({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Greater or Equal than logic operator}\par
00370 {\cf20 }            {\cf18 bool} operator <=({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Lesser or Equal than logic operator}\par
00376 {\cf20 }            Polynomial operator +({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Addition operator}\par
00382 {\cf20 }            Polynomial operator -({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Substraction operator}\par
00388 {\cf20 }            Polynomial operator *({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Multiplication operator}\par
00394 {\cf20 }            Polynomial operator /({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Division operator}\par
00400 {\cf20 }            Polynomial operator %({\cf17 const} Polynomial& ogn) {\cf17 const} {\cf17 noexcept}; {\cf20 //Modulus operator}\par
00406 {\cf20 }            Polynomial& operator +=({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Addition assigment operator}\par
00412 {\cf20 }            Polynomial& operator -=({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Substraction assigment operator}\par
00418 {\cf20 }            Polynomial& operator *=({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Multiplication assigment operator}\par
00424 {\cf20 }            Polynomial& operator /=({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Division assigment operator}\par
00430 {\cf20 }            Polynomial& operator %=({\cf17 const} Polynomial& ogn) {\cf17 noexcept}; {\cf20 //Modulus assigment operator}\par
00437 {\cf20 }            {\cf17 friend} std::stringstream& operator<<(std::stringstream& ss, {\cf17 const} Polynomial& p) {\cf17 noexcept}; {\cf20 //Stream operator}\par
00444 {\cf20 }            {\cf17 friend} std::ostream& operator<<(std::ostream& out, {\cf17 const} Polynomial& p) {\cf17 noexcept}; {\cf20 //Stream operator}\par
00449 {\cf20 }            {\cf18 int} get_degree() const noexcept; {\cf20 //Degree getter}\par
00454 {\cf20 }            std::map<{\cf18 int}, Monomial> get_monomials()  const noexcept; {\cf20 //Monomials getter}\par
00460 {\cf20 }            {\cf18 bool} push_monomial(const Monomial& m) noexcept; {\cf20 //Monomials appender}\par
00466 {\cf20 }            {\cf18 bool} push_monomial(Monomial&& m) noexcept; {\cf20 //Monomials appender}\par
00471 {\cf20 }            std::{\cf18 string} get_expression() const noexcept; {\cf20 //String expression getter}\par
00477 {\cf20 }            {\cf18 double} get_value(const {\cf18 double}& x) const noexcept; {\cf20 //Value for x getter}\par
00482 {\cf20 }            Polynomial get_derivative() const noexcept; {\cf20 //Gets the derivative}\par
00487 {\cf20 }            Polynomial get_integral() const noexcept; {\cf20 //Gets the integral}\par
00491 {\cf20 }            ~Polynomial(); {\cf20 //Destructor}\par
00492         private:\par
00496             std::map<{\cf18 int}, Monomial> monomials;\par
00501             {\cf18 void} swap(Polynomial& ogn) noexcept; {\cf20 //Swap function}\par
00505 {\cf20 }            Polynomial& redux() noexcept; {\cf20 //Reduces the polynomial}\par
00506     \};\par
00507 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/eparser.h File Reference\par \pard\plain 
{\tc\tcl2 \v include/eparser.h}
{\xe \v include/eparser.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main header file for the equation parser. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include "emath.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for eparser.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "eparser_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "eparser_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b emthp::Token}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct for representing a token as a type and a value. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b emthp::Lexer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that works as a token supplier for the {\b Parser} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b emthp::Parser}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that wraps a std::string and parses it as a Monomial or as a Polynomial. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b emthp}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Englobes all the classes and functions of the parser. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b emthp::TokenType} \{ {\b emthp::T_PLUS}
, {\b T_MINUS}
, {\b T_NUMBER}
, {\b T_VARIABLE}
, {\b T_EXPONENT}
, {\b T_EOF}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum with all the possible Token types. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main header file for the equation parser. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the classes and functions for parsing polynomials and monomials.\par
It consists of two classes, the Parser class and the Lexer class.\par
The Parser class consists of two functions, one for parsing the entire input as a Polynomial and another for parsing a Monomial at a time.\par
The Lexer class just provides a token supplier for the Parser class.\par
}{
Definition in file {\b eparser.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
eparser.h\par \pard\plain 
{\tc\tcl2 \v include/eparser.h}
{\xe \v include/eparser.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00009 {\cf21 #include <string>}\par
00010 {\cf21 #include "emath.h"}\par
00016 {\cf17 namespace }emthp \{\par
00021     {\cf17 enum} TokenType \{\par
00025         T_PLUS,\par
00026         T_MINUS,\par
00027         T_NUMBER,\par
00028         T_VARIABLE,\par
00029         T_EXPONENT,\par
00030         T_EOF\par
00031     \};\par
00036     {\cf17 struct }Token \{\par
00037         {\cf17 public}:\par
00041             TokenType type;\par
00045             {\cf18 double} value;\par
00046     \};\par
00052     {\cf17 class }Lexer \{\par
00053         {\cf17 public}:\par
00058             Lexer({\cf17 const} std::string& input) {\cf17 noexcept};\par
00064             Lexer& operator =({\cf17 const} Lexer& ogn) {\cf17 noexcept};\par
00069             Token next() {\cf17 noexcept};\par
00073             {\cf18 void} back() {\cf17 noexcept};\par
00074         {\cf17 private}:\par
00078             std::string _input;\par
00082             {\cf18 long} {\cf18 unsigned} {\cf18 int} _pos;\par
00087             {\cf18 double} read_number() {\cf17 noexcept};\par
00093             {\cf17 static} std::string clean({\cf17 const} std::string& input) {\cf17 noexcept};\par
00100             {\cf17 static} {\cf17 constexpr} {\cf17 inline} {\cf18 bool} is_digit({\cf17 const} {\cf18 char}& c) {\cf17 noexcept} \{{\cf19 return} ((c >= {\cf23 '0'} && c <= {\cf23 '9'}) || c == {\cf23 '.'});\}\par
00101     \};\par
00107     {\cf17 class }Parser \{\par
00108         {\cf17 public}:\par
00113             Parser({\cf17 const} std::string& input) {\cf17 noexcept};\par
00119             Parser& operator =({\cf17 const} Parser& ogn) {\cf17 noexcept};\par
00124             emth::Polynomial parse_polynomial() {\cf17 noexcept};\par
00129             emth::Monomial parse_monomial() {\cf17 noexcept};\par
00130         {\cf17 private}:\par
00134             Lexer _lexer;\par
00139             {\cf18 double} parse_number() {\cf17 noexcept};\par
00140     \};\par
00141 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/emath.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/emath.cpp}
{\xe \v src/emath.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main source file for the mathematical equation operations. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "emath.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for emath.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "src_2emath_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main source file for the mathematical equation operations. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file implements the functions declared in {\b emath.h}.\par
It consists of two classes, the Monomial class and the Polynomial class.\par
The Monomial class implements all the functions, operators, and properties for representing and operating monomials.\par
The Polynomial class implements all the functions, operators, and properties for representing and operating polynomials.\par
}{
Definition in file {\b emath.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emath.cpp\par \pard\plain 
{\tc\tcl2 \v src/emath.cpp}
{\xe \v src/emath.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00009 {\cf21 #include "emath.h"}\par
00015 {\cf18 void} emth::Arithmetic::get_divisors({\cf18 int} n, std::vector<int>& v) {\cf17 noexcept} \{\par
00016     {\cf18 int} limit(std::sqrt(n));\par
00017     {\cf19 for} ({\cf18 int} i = 1; i <= limit; i++) \{\par
00018         {\cf19 if} (std::fmod(n, i) == 0) \{\par
00019             v.push_back(i);\par
00020             {\cf19 if} (i != n / i) \{\par
00021                 v.push_back(n / i);\par
00022             \}\par
00023         \}\par
00024     \}\par
00025     {\cf19 return};\par
00026 \}\par
00030 emth::Monomial::Monomial() noexcept : coeff(0), degree(0) \{\}\par
00036 emth::Monomial::Monomial({\cf17 const} {\cf18 double} cf, {\cf17 const} {\cf18 int} dgr) noexcept : coeff(cf), degree(dgr) \{\}\par
00041 emth::Monomial::Monomial({\cf17 const} Monomial& ogn) noexcept : coeff(ogn.coeff), degree(ogn.degree) \{\}\par
00046 emth::Monomial::Monomial(Monomial&& ogn) noexcept : coeff(std::move(ogn.coeff)), degree(std::move(ogn.degree)) \{\}\par
00052 emth::Monomial& emth::Monomial::operator =({\cf17 const} emth::Monomial& ogn) {\cf17 noexcept} \{Monomial copy(ogn); this->swap(copy); {\cf19 return} *{\cf17 this};\}\par
00058 emth::Monomial& emth::Monomial::operator =(emth::Monomial&& ogn) {\cf17 noexcept} \{this->swap(ogn); {\cf19 return} *{\cf17 this};\}\par
00065 {\cf18 bool} emth::Monomial::operator ==({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} ((this->coeff == ogn.coeff) && (this->degree == ogn.degree));\}\par
00072 {\cf18 bool} emth::Monomial::operator !=({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (!(*{\cf17 this} == ogn));\}\par
00079 {\cf18 bool} emth::Monomial::operator >({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->degree > ogn.degree);\};\par
00086 {\cf18 bool} emth::Monomial::operator <({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->degree < ogn.degree);\};\par
00093 {\cf18 bool} emth::Monomial::operator >=({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->degree >= ogn.degree);\};\par
00100 {\cf18 bool} emth::Monomial::operator <=({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->degree <= ogn.degree);\};\par
00106 emth::Monomial emth::Monomial::operator +({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Monomial(*{\cf17 this}) += ogn;\}\par
00112 emth::Monomial emth::Monomial::operator -({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Monomial(*{\cf17 this}) -= ogn;\}\par
00118 emth::Monomial emth::Monomial::operator *({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Monomial(*{\cf17 this}) *= ogn;\}\par
00124 emth::Monomial emth::Monomial::operator /({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Monomial(*{\cf17 this}) /= ogn;\}\par
00130 emth::Monomial emth::Monomial::operator %({\cf17 const} emth::Monomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Monomial(*{\cf17 this}) %= ogn;\}\par
00136 emth::Monomial& emth::Monomial::operator +=({\cf17 const} emth::Monomial& ogn) {\cf17 noexcept} \{\par
00137     {\cf19 if} ((this->degree == ogn.degree) || this->coeff == 0) \{\par
00138         {\cf19 if} (this->coeff == 0) \{this->degree = ogn.degree;\}\par
00139         this->coeff += ogn.coeff;\par
00140     \}\par
00141     {\cf19 return} *{\cf17 this};\par
00142 \}\par
00148 emth::Monomial& emth::Monomial::operator -=({\cf17 const} emth::Monomial& ogn) {\cf17 noexcept} \{\par
00149     {\cf19 if} ((this->degree == ogn.degree) || this->coeff == 0) \{\par
00150         {\cf19 if} (this->coeff == 0) \{this->degree = ogn.degree;\}\par
00151         this->coeff -= ogn.coeff;\par
00152     \}\par
00153     {\cf19 return} *{\cf17 this};\par
00154 \}\par
00160 emth::Monomial& emth::Monomial::operator *=({\cf17 const} emth::Monomial& ogn) {\cf17 noexcept} \{\par
00161     this->coeff *= ogn.coeff;\par
00162     this->degree += ogn.degree;\par
00163     {\cf19 return} *{\cf17 this};\par
00164 \}\par
00170 emth::Monomial& emth::Monomial::operator /=({\cf17 const} emth::Monomial& ogn) {\cf17 noexcept} \{\par
00171     {\cf19 if} (ogn.coeff != 0) \{\par
00172         this->coeff /= ogn.coeff;\par
00173         this->degree -= ogn.degree;\par
00174     \}\par
00175     {\cf19 return} *{\cf17 this};\par
00176 \}\par
00182 emth::Monomial& emth::Monomial::operator %=({\cf17 const} emth::Monomial& ogn) {\cf17 noexcept} \{\par
00183     {\cf19 if} (ogn.coeff != 0) \{\par
00184         this->coeff = std::fmod(this->coeff, ogn.coeff);\par
00185         this->degree -= ogn.degree;\par
00186     \}\par
00187     {\cf19 return} *{\cf17 this};\par
00188 \}\par
00195 std::stringstream& emth::operator<<(std::stringstream& ss, {\cf17 const} emth::Monomial& m) \{ss << m.coeff << {\cf22 "x^"} << m.degree; {\cf19 return} ss;\}\par
00202 std::ostream& emth::operator<<(std::ostream& out, {\cf17 const} emth::Monomial& m) \{out << m.coeff << {\cf22 "x^"} << m.degree; {\cf19 return} out;\}\par
00207 {\cf18 double} emth::Monomial::get_coeff() const noexcept \{{\cf19 return} this->coeff;\}\par
00212 {\cf18 int} emth::Monomial::get_degree() const noexcept \{{\cf19 return} this->degree;\}\par
00217 {\cf18 void} emth::Monomial::set_coeff({\cf18 double} cf) {\cf17 noexcept} \{this->coeff = cf; {\cf19 return};\}\par
00222 {\cf18 void} emth::Monomial::set_degree({\cf18 int} dgr) {\cf17 noexcept} \{this->degree = dgr; {\cf19 return};\}\par
00227 std::string emth::Monomial::get_expression() const noexcept \{{\cf19 return} (std::stringstream() << *{\cf17 this}).str();\}\par
00233 {\cf18 double} emth::Monomial::get_value({\cf17 const} {\cf18 double}& x) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->coeff * std::pow(x, this->degree));\};\par
00238 {\cf18 void} emth::Monomial::swap(emth::Monomial& ogn) {\cf17 noexcept} \{\par
00239     std::swap(this->coeff, ogn.coeff);\par
00240     std::swap(this->degree, ogn.degree);\par
00241     {\cf19 return};\par
00242 \}\par
00246 emth::Monomial::~Monomial() = {\cf19 default};\par
00250 emth::Polynomial::Polynomial() noexcept \{this->monomials[0] = emth::Monomial(0, 0);\}\par
00255 emth::Polynomial::Polynomial({\cf17 const} std::map<int, emth::Monomial> mns) noexcept : monomials(mns) \{\}\par
00260 emth::Polynomial::Polynomial({\cf17 const} std::initializer_list<emth::Monomial> mns) {\cf17 noexcept} \{{\cf19 for}({\cf17 const} emth::Monomial& mn: mns) \{this->monomials.emplace(mn.get_degree(), mn);\}\}\par
00265 emth::Polynomial::Polynomial({\cf17 const} std::vector<emth::Monomial> mns) {\cf17 noexcept} \{{\cf19 for}({\cf17 const} emth::Monomial& mn: mns) \{this->monomials.emplace(mn.get_degree(), mn);\}\}\par
00270 emth::Polynomial::Polynomial({\cf17 const} emth::Polynomial& ogn) noexcept : monomials(ogn.monomials) \{\} \par
00275 emth::Polynomial::Polynomial(emth::Polynomial&& ogn) noexcept : monomials(std::move(ogn.monomials)) \{\}\par
00281 emth::Polynomial& emth::Polynomial::operator =({\cf17 const} emth::Polynomial& ogn) {\cf17 noexcept} \{emth::Polynomial copy(ogn); this->swap(copy); {\cf19 return} *{\cf17 this};\}\par
00287 emth::Polynomial& emth::Polynomial::operator =(emth::Polynomial&& ogn) {\cf17 noexcept} \{this->swap(ogn); {\cf19 return} *{\cf17 this};\}\par
00294 {\cf18 bool} emth::Polynomial::operator ==({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} ((this->get_degree() == ogn.get_degree()) && (this->monomials == ogn.monomials));\}\par
00301 {\cf18 bool} emth::Polynomial::operator !=({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (!(*{\cf17 this} == ogn));\}\par
00308 {\cf18 bool} emth::Polynomial::operator >({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->get_degree() > ogn.get_degree());\};\par
00315 {\cf18 bool} emth::Polynomial::operator <({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->get_degree() < ogn.get_degree());\};\par
00322 {\cf18 bool} emth::Polynomial::operator >=({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->get_degree() >= ogn.get_degree());\};\par
00329 {\cf18 bool} emth::Polynomial::operator <=({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} (this->get_degree() <= ogn.get_degree());\};\par
00335 emth::Polynomial emth::Polynomial::operator +({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Polynomial(*{\cf17 this}) += ogn;\}\par
00341 emth::Polynomial emth::Polynomial::operator -({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Polynomial(*{\cf17 this}) -= ogn;\}\par
00347 emth::Polynomial emth::Polynomial::operator *({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Polynomial(*{\cf17 this}) *= ogn;\}\par
00353 emth::Polynomial emth::Polynomial::operator /({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Polynomial(*{\cf17 this}) /= ogn;\}\par
00359 emth::Polynomial emth::Polynomial::operator %({\cf17 const} emth::Polynomial& ogn) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} emth::Polynomial(*{\cf17 this}) %= ogn;\}\par
00365 emth::Polynomial& emth::Polynomial::operator +=({\cf17 const} emth::Polynomial& ogn) {\cf17 noexcept} \{\par
00366     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv : ogn.monomials) \{this->monomials[kv.first] += kv.second;\}\par
00367     {\cf19 return} this->redux();\par
00368 \}\par
00374 emth::Polynomial& emth::Polynomial::operator -=({\cf17 const} emth::Polynomial& ogn) {\cf17 noexcept} \{\par
00375     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv : ogn.monomials) \{this->monomials[kv.first] -= kv.second;\}\par
00376     {\cf19 return} this->redux();\par
00377 \}\par
00383 emth::Polynomial& emth::Polynomial::operator *=({\cf17 const} emth::Polynomial& ogn) {\cf17 noexcept} \{\par
00384     std::map<int, emth::Monomial> rs;\par
00385     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv : this->monomials) \{\par
00386         {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kkvv : ogn.monomials) \{\par
00387             rs[kv.first + kkvv.first] += kv.second * kkvv.second;\par
00388         \}\par
00389     \}\par
00390     this->monomials = std::move(rs);\par
00391     {\cf19 return} this->redux();\par
00392 \}\par
00398 emth::Polynomial& emth::Polynomial::operator /=({\cf17 const} emth::Polynomial& ogn) {\cf17 noexcept} \{\par
00399     {\cf19 if} (!ogn.monomials.empty()) \{\par
00400         emth::Polynomial quotient;\par
00401         {\cf19 while} (!this->monomials.empty() && this->monomials.crbegin()->second.get_degree() >= ogn.monomials.crbegin()->second.get_degree()) \{\par
00402             emth::Monomial mon = this->monomials.crbegin()->second / ogn.monomials.crbegin()->second;\par
00403             quotient.monomials[mon.get_degree()] = mon;\par
00404             *{\cf17 this} -= (ogn * emth::Polynomial(\{mon\}));\par
00405         \}\par
00406         this->monomials = quotient.monomials;\par
00407     \}\par
00408     {\cf19 return} this->redux();\par
00409 \}\par
00415 emth::Polynomial& emth::Polynomial::operator %=({\cf17 const} emth::Polynomial& ogn) {\cf17 noexcept} \{\par
00416     {\cf19 if} (!ogn.monomials.empty()) \{\par
00417         {\cf19 while} (!this->monomials.empty() && this->monomials.crbegin()->second.get_degree() >= ogn.monomials.crbegin()->second.get_degree()) \{\par
00418             emth::Monomial mon = this->monomials.crbegin()->second / ogn.monomials.crbegin()->second;\par
00419             *{\cf17 this} -= (ogn * emth::Polynomial(\{mon\}));\par
00420         \}\par
00421     \}\par
00422     {\cf19 return} this->redux();\par
00423 \}\par
00430 std::stringstream& emth::operator<<(std::stringstream& ss, {\cf17 const} emth::Polynomial& p) {\cf17 noexcept} \{\par
00431     {\cf19 for}(std::reverse_iterator<std::map<const int, emth::Monomial>::const_iterator> it = p.monomials.crbegin(); it != p.monomials.crend(); it++) \{ss << it->second << {\cf22 " "};\}\par
00432     {\cf19 return} ss;\par
00433 \}\par
00440 std::ostream& emth::operator<<(std::ostream& out, {\cf17 const} emth::Polynomial& p) {\cf17 noexcept} \{\par
00441     {\cf19 for}(std::reverse_iterator<std::map<const int, emth::Monomial>::const_iterator> it = p.monomials.crbegin(); it != p.monomials.crend(); it++) \{out << it->second << {\cf22 " "};\}\par
00442     {\cf19 return} out;\par
00443 \}\par
00448 {\cf18 int} emth::Polynomial::get_degree() const noexcept \{{\cf19 return} this->monomials.crbegin()->first;\}\par
00453 std::map<int, emth::Monomial> emth::Polynomial::get_monomials() const noexcept \{{\cf19 return} this->monomials;\}\par
00459 {\cf18 bool} emth::Polynomial::push_monomial({\cf17 const} emth::Monomial& m) {\cf17 noexcept} \{this->push_monomial(emth::Monomial(m));\};\par
00465 {\cf18 bool} emth::Polynomial::push_monomial(emth::Monomial&& m) {\cf17 noexcept} \{\par
00466     {\cf19 if} (m.get_coeff() == 0) \{{\cf19 return} {\cf17 false};\}\par
00467     this->monomials[m.get_degree()] += m;\par
00468     this->redux();\par
00469     {\cf19 return} {\cf17 true};\par
00470 \};\par
00475 std::string emth::Polynomial::get_expression() const noexcept \{{\cf19 return} (std::stringstream() << *{\cf17 this}).str();\}\par
00481 {\cf18 double} emth::Polynomial::get_value({\cf17 const} {\cf18 double}& x) {\cf17 const} {\cf17 noexcept} \{\par
00482     {\cf18 double} y = 0;\par
00483     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv: this->monomials) \{y += kv.second.get_value(x);\}\par
00484     {\cf19 return} y;\par
00485 \};\par
00490 emth::Polynomial emth::Polynomial::get_derivative() const noexcept \{\par
00491     std::map<int, emth::Monomial> fdx;\par
00492     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv: this->monomials) \{\par
00493         {\cf19 if} (kv.second.get_degree() != 0) \{fdx[kv.second.get_degree() - 1] = emth::Monomial(kv.second.get_coeff() * kv.second.get_degree(), kv.second.get_degree() - 1);\}\par
00494     \}\par
00495     {\cf19 return} emth::Polynomial(std::move(fdx)).redux();\par
00496 \};\par
00501 emth::Polynomial emth::Polynomial::get_integral() const noexcept \{\par
00502     std::map<int, emth::Monomial> sdx;\par
00503     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv: this->monomials) \{\par
00504         sdx[kv.second.get_degree() + 1] = emth::Monomial(kv.second.get_coeff() / (kv.second.get_degree() + 1), kv.second.get_degree() + 1);\par
00505     \}\par
00506     {\cf19 return} emth::Polynomial(std::move(sdx)).redux();\par
00507 \};\par
00512 {\cf18 void} emth::Polynomial::swap(emth::Polynomial& ogn) {\cf17 noexcept} \{\par
00513     std::swap(this->monomials, ogn.monomials);\par
00514     {\cf19 return};\par
00515 \}\par
00519 emth::Polynomial& emth::Polynomial::redux() noexcept \{\par
00520     std::vector<int> ks;\par
00521     {\cf19 for}({\cf17 const} std::pair<const int, emth::Monomial>& kv: this->monomials) \{\par
00522         {\cf19 if} (kv.second.get_coeff() == 0) \{ks.push_back(kv.first);\}\par
00523     \}\par
00524     {\cf19 for}({\cf18 int}& k: ks) \{this->monomials.erase(k);\}\par
00525     {\cf19 return} *{\cf17 this};\par
00526 \}\par
00530 emth::Polynomial::~Polynomial() = {\cf19 default};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/emath.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v test/emath.cpp}
{\xe \v test/emath.cpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main test file of the emath library. It contains all the tests needed to assure that the library works properly. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cassert>}\par
{\f2 #include <iostream>}\par
{\f2 #include "emath.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for emath.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2emath_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_monomial} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs all the monomial class tests. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_polynomial} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs all the polynomial class tests. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the monomial and polynomial tests. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main test file of the emath library. It contains all the tests needed to assure that the library works properly. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains a main function that calls a function for the monomials and a function for the polynomials that test that every method works as it should.\par
If it doesn't then a message gets printed to the console describing the error. If this does happen open an issue on my github page. \par
}{
Definition in file {\b emath.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:emath.cpp}
{\xe \v emath.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the monomial and polynomial tests. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(int) The sum of the test_monomial and test_polynomial function wich should be zero when all tests pass \par
}}}{
Definition at line {\b 206} of file {\b emath.cpp}.}\par
{
\ql
References {\b test_monomial()}, and {\b test_polynomial()}.}\par
}
{\xe \v test_monomial\:emath.cpp}
{\xe \v emath.cpp\:test_monomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int test_monomial ()}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs all the monomial class tests. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(int) Returns 0 to specify to Meson that the tests finished correctly \par
}}}{
Definition at line {\b 15} of file {\b emath.cpp}.}\par
{
\ql
References {\b emth::Monomial::get_coeff()}, {\b emth::Monomial::get_degree()}, {\b emth::Monomial::get_expression()}, and {\b emth::Monomial::get_value()}.}\par
}
{\xe \v test_polynomial\:emath.cpp}
{\xe \v emath.cpp\:test_polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int test_polynomial ()}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs all the polynomial class tests. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(int) Returns 0 to specify to Meson that the tests finished correctly \par
}}}{
Definition at line {\b 102} of file {\b emath.cpp}.}\par
{
\ql
References {\b emth::Polynomial::get_degree()}, {\b emth::Polynomial::get_derivative()}, {\b emth::Polynomial::get_expression()}, {\b emth::Polynomial::get_integral()}, {\b emth::Polynomial::get_monomials()}, and {\b emth::Polynomial::get_value()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
emath.cpp\par \pard\plain 
{\tc\tcl2 \v test/emath.cpp}
{\xe \v test/emath.cpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include <cassert>}\par
00008 {\cf21 #include <iostream>}\par
00009 {\cf21 #include "emath.h"}\par
00010 {\cf17 using namespace }emth;\par
00015 {\cf18 int} test_monomial() \{\par
00016     {\cf20 //--------------------------------------}\par
00017     {\cf20 //             CONSTRUCTORS}\par
00018     {\cf20 //--------------------------------------}\par
00019     {\cf20 // Default constructor}\par
00020     Monomial md;\par
00021     assert((md.get_coeff() == 0) && {\cf22 "Error on default Monomial constructor: coeff is not default!"});\par
00022     assert((md.get_degree() == 0) && {\cf22 "Error on default Monomial constructor: degree is not default!"});\par
00023     {\cf20 // Normal constructor}\par
00024     Monomial mn(1, 1);\par
00025     assert((mn.get_coeff() == 1) && {\cf22 "Error on normal Monomial constructor: coeff is not coeff!"});\par
00026     assert((mn.get_degree() == 1) && {\cf22 "Error on normal Monomial constructor: degree is not degree!"});\par
00027     {\cf20 // Copy constructor}\par
00028     Monomial mc(mn);\par
00029     assert((mc.get_coeff() == 1) && {\cf22 "Error on copy Monomial constructor: coeff is not copy coeff!"});\par
00030     assert((mc.get_degree() == 1) && {\cf22 "Error on copy Monomial constructor: degree is not copy degree!"});\par
00031     {\cf20 // Move constructor}\par
00032     Monomial mm(Monomial(2,2));\par
00033     assert((mm.get_coeff() == 2) && {\cf22 "Error on move Monomial constructor: coeff is not move coeff!"});\par
00034     assert((mm.get_degree() == 2) && {\cf22 "Error on move Monomial constructor: degree is not move degree!"});\par
00035     {\cf20 //--------------------------------------}\par
00036     {\cf20 //             ASSIGMENT}\par
00037     {\cf20 //--------------------------------------}\par
00038     {\cf20 // Copy assigment}\par
00039     mc = mm;\par
00040     assert((mc.get_coeff() == 2) && {\cf22 "Error on copy assigment operator: coeff is not copy coeff!"});\par
00041     assert((mc.get_degree() == 2) && {\cf22 "Error on copy assigment operator: degree is not copy degree!"});\par
00042     {\cf20 // Move assigment}\par
00043     mm = Monomial(3, 3);\par
00044     assert((mm.get_coeff() == 3) && {\cf22 "Error on move assigment operator: coeff is not move coeff!"});\par
00045     assert((mm.get_degree() == 3) && {\cf22 "Error on move assigment operator: degree is not move degree!"});\par
00046     {\cf20 //--------------------------------------}\par
00047     {\cf20 //             COMPARISON}\par
00048     {\cf20 //--------------------------------------}\par
00049     {\cf17 const} Monomial m1(1, 1), m2(2, 2);\par
00050     {\cf20 // Equality}\par
00051     assert((m1 == m1) && (m1 == Monomial(1, 1)) && (Monomial(1, 1) == m1) && (Monomial(1, 1) == Monomial(1, 1)) && {\cf22 "Error on equal operator: equal monomials are not diffent!"});\par
00052     assert((m1 != m2) && (m1 != Monomial(2, 2)) && (Monomial(2, 2) != m1) && (Monomial(1, 1) != Monomial(2, 2)) && {\cf22 "Error on equal operator: diffent monomials are not equal!"});\par
00053     {\cf20 // Size}\par
00054     assert((m2 > m1) && (m2 > Monomial(1, 1)) && (Monomial(2, 2) > m1) && (Monomial(2, 2) > Monomial(1, 1)) && {\cf22 "Error on greater monomial operator!"});\par
00055     assert((m1 < m2) && (m1 < Monomial(2, 2)) && (Monomial(1, 1) < m2) && (Monomial(1, 1) < Monomial(2, 2)) && {\cf22 "Error on lesser monomial operator!"});\par
00056     assert((m2 >= m1 && m2 >= m2) && (m2 >= Monomial(1, 1) && m2 >= Monomial(2, 2)) && (Monomial(2, 2) >= m1 && Monomial(2, 2) >= m2) && (Monomial(2, 2) >= Monomial(1, 1) && Monomial(2, 2) >= Monomial(2, 2)) && {\cf22 "Error on greater or equal monomial operator!"});\par
00057     assert((m1 <= m2 && m1 <= m1) && (m1 <= Monomial(2, 2) && m1 <= Monomial(1, 1)) && (Monomial(1, 1) <= m2 && Monomial(1, 1) <= m1) && (Monomial(1, 1) <= Monomial(2, 2) && Monomial(1, 1) >= Monomial(1, 1)) && {\cf22 "Error on lesser or equal monomial operator!"});\par
00058     {\cf20 //--------------------------------------}\par
00059     {\cf20 //             ARITHMETIC}\par
00060     {\cf20 //--------------------------------------}\par
00061     Monomial m3(3, 3), m4(4, 4), mn3(-3, -3), mn4(-4, -4);\par
00062     {\cf20 // Addition}\par
00063     assert(((m3 + m4).get_coeff() == 3) && ((m3 + m4).get_degree() == 3) && {\cf22 "Error on addition operator: different degree monomials addition didnt return default value"});\par
00064     assert(((m3 + m3).get_coeff() == 6) && ((m3 + m3).get_degree() == 3) && ((Monomial(3, 3) + Monomial(3, 3)).get_coeff() == 6) && ((Monomial(3, 3) + Monomial(3, 3)).get_degree() == 3) && {\cf22 "Error on addition operator: positive values addition failed!"});\par
00065     assert(((mn3 + mn3).get_coeff() == -6) && ((mn3 + mn3).get_degree() == -3) && ((Monomial(-3, -3) + Monomial(-3, -3)).get_coeff() == -6) && ((Monomial(-3, -3) + Monomial(-3, -3)).get_degree() == -3) && {\cf22 "Error on addition operator: negative values addition failed!"});\par
00066     {\cf20 // Substraction}\par
00067     assert(((m3 - m4).get_coeff() == 3) && ((m3 - m4).get_degree() == 3) && {\cf22 "Error on substraction operator: different degree monomials substraction didnt return default value"});\par
00068     assert(((m3 - m3).get_coeff() == 0) && ((m3 - m3).get_degree() == 3) && ((Monomial(3, 3) - Monomial(3, 3)).get_coeff() == 0) && ((Monomial(3, 3) - Monomial(3, 3)).get_degree() == 3) && {\cf22 "Error on substraction operator: positive values substraction failed!"});\par
00069     assert(((mn3 - mn3).get_coeff() == 0) && ((mn3 - mn3).get_degree() == -3) && ((Monomial(-3, -3) - Monomial(-3, -3)).get_coeff() == 0) && ((Monomial(-3, -3) - Monomial(-3, -3)).get_degree() == -3) && {\cf22 "Error on substraction operator: negative values substraction failed!"});\par
00070     {\cf20 // Multiplication}\par
00071     assert(((m3 * m4).get_coeff() == 12) && ((m3 * m4).get_degree() == 7) && ((Monomial(3, 3) * Monomial(4, 4)).get_coeff() == 12) && ((Monomial(3, 3) * Monomial(4, 4)).get_degree() == 7) && {\cf22 "Error on multiplication operator: positive values multiplication failed!"});\par
00072     assert(((mn3 * mn4).get_coeff() == 12) && ((mn3 * mn4).get_degree() == -7) && ((Monomial(-3, -3) * Monomial(-4, -4)).get_coeff() == 12) && ((Monomial(-3, -3) * Monomial(-4, -4)).get_degree() == -7) && {\cf22 "Error on multiplication operator: negative values multiplication failed!"});\par
00073     {\cf20 // Division}\par
00074     assert(((m3 / Monomial(0, 0)).get_coeff() == 3) && ((m3 / Monomial(0, 0)).get_degree() == 3) && {\cf22 "Error on division operator: divide by zero didnt return default value"});\par
00075     assert(((m3 / m4).get_coeff() == 0.75) && ((m3 / m4).get_degree() == -1) && ((Monomial(3, 3) / Monomial(4, 4)).get_coeff() == 0.75) && ((Monomial(3, 3) / Monomial(4, 4)).get_degree() == -1) && {\cf22 "Error on division operator: positive values division failed!"});\par
00076     assert(((mn3 / mn4).get_coeff() == 0.75) && ((mn3 / mn4).get_degree() == 1) && ((Monomial(-3, -3) / Monomial(-4, -4)).get_coeff() == 0.75) && ((Monomial(-3, -3) / Monomial(-4, -4)).get_degree() == 1) && {\cf22 "Error on division operator: negative values division failed!"});\par
00077     {\cf20 // Modulus}\par
00078     assert(((m3 % Monomial(0, 0)).get_coeff() == 3) && ((m3 % Monomial(0, 0)).get_degree() == 3) && {\cf22 "Error on modulus operator: divide by zero didnt return default value"});\par
00079     assert(((m4 % m3).get_coeff() == 1) && ((m4 % m3).get_degree() == 1) && ((Monomial(4, 4) % Monomial(3, 3)).get_coeff() == 1) && ((Monomial(4, 4) % Monomial(3, 3)).get_degree() == 1) && {\cf22 "Error on modulus operator: positive values modulus failed!"});\par
00080     assert(((mn4 % mn3).get_coeff() == -1) && ((mn4 % mn3).get_degree() == -1) && ((Monomial(-4, -4) % Monomial(-3, -3)).get_coeff() == -1) && ((Monomial(-4, -4) % Monomial(-3, -3)).get_degree() == -1) && {\cf22 "Error on modulus operator: negative values modulus failed!"});\par
00081     {\cf20 //--------------------------------------}\par
00082     {\cf20 //               STREAM}\par
00083     {\cf20 //--------------------------------------}\par
00084     std::stringstream ss, sss;\par
00085     Monomial m5(5, 5), mn5(-5, -5);\par
00086     assert(((ss << m5).str() == {\cf22 "5x^5"}) && ((sss << mn5).str() == {\cf22 "-5x^-5"}) && {\cf22 "Error on stream operator!"});\par
00087     {\cf20 //--------------------------------------}\par
00088     {\cf20 //                 MISC}\par
00089     {\cf20 //--------------------------------------}\par
00090     {\cf20 // Expression getter}\par
00091     assert((m5.get_expression() == {\cf22 "5x^5"}) && (mn5.get_expression() == {\cf22 "-5x^-5"}) && {\cf22 "Error on expression getter!"});\par
00092     {\cf20 // Value getter}\par
00093     assert((m5.get_value(2) == 160) && (mn5.get_value(2) == -0.15625) && {\cf22 "Error on value getter!"});\par
00094     {\cf20 // Well done!}\par
00095     std::cout << {\cf22 "Monomial tests passed!"} << std::endl;\par
00096     {\cf19 return} 0;\par
00097 \}\par
00102 {\cf18 int} test_polynomial() \{\par
00103     {\cf20 //--------------------------------------}\par
00104     {\cf20 //             CONSTRUCTORS}\par
00105     {\cf20 //--------------------------------------}\par
00106     {\cf20 // Default constructor}\par
00107     Polynomial pd;\par
00108     assert((pd.get_monomials().crbegin()->second.get_coeff() == 0) && {\cf22 "Error on default Polynomial constructor: monomial coeff is not default!"});\par
00109     assert((pd.get_monomials().crbegin()->second.get_degree() == 0) && {\cf22 "Error on default Polynomial constructor: monomial degree is not default!"});\par
00110     {\cf20 // Normal constructor}\par
00111     Polynomial pn(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}\}));\par
00112     assert((pn.get_monomials().crbegin()->second.get_coeff() == 1) && {\cf22 "Error on normal Polynomial constructor: monomial coeff is not coeff!"});\par
00113     assert((pn.get_monomials().crbegin()->second.get_degree() == 1) && {\cf22 "Error on normal Polynomial constructor: monomial degree is not degree!"});\par
00114     assert((pn.get_degree() == 1) && {\cf22 "Error on normal Polynomial constructor: polynomial degree is not degree!"});\par
00115     {\cf20 // List constructor}\par
00116     Polynomial pl(\{Monomial(1, 1), Monomial(2, 2)\});\par
00117     assert((pl.get_monomials().crbegin()->second.get_coeff() == 2) && {\cf22 "Error on list Polynomial constructor: last monomial coeff is not coeff!"});\par
00118     assert((pl.get_monomials().crbegin()->second.get_degree() == 2) && {\cf22 "Error on list Polynomial constructor: last monomial degree is not degree!"});\par
00119     assert((pl.get_monomials().cbegin()->second.get_coeff() == 1) && {\cf22 "Error on list Polynomial constructor: first monomial coeff is not coeff!"});\par
00120     assert((pl.get_monomials().cbegin()->second.get_degree() == 1) && {\cf22 "Error on list Polynomial constructor: first monomial degree is not degree!"});\par
00121     assert((pl.get_degree() == 2) && {\cf22 "Error on list Polynomial constructor: polynomial degree is not degree!"});\par
00122     {\cf20 // Vector constructor}\par
00123     Polynomial pv(std::vector<Monomial>(\{Monomial(1, 1), Monomial(2, 2)\}));\par
00124     assert((pv.get_monomials().crbegin()->second.get_coeff() == 2) && {\cf22 "Error on vector Polynomial constructor: last monomial coeff is not coeff!"});\par
00125     assert((pv.get_monomials().crbegin()->second.get_degree() == 2) && {\cf22 "Error on vector Polynomial constructor: last monomial degree is not degree!"});\par
00126     assert((pv.get_monomials().cbegin()->second.get_coeff() == 1) && {\cf22 "Error on vector Polynomial constructor: first monomial coeff is not coeff!"});\par
00127     assert((pv.get_monomials().cbegin()->second.get_degree() == 1) && {\cf22 "Error on vector Polynomial constructor: first monomial degree is not degree!"});\par
00128     assert((pv.get_degree() == 2) && {\cf22 "Error on vector Polynomial constructor: polynomial degree is not degree!"});\par
00129     {\cf20 // Copy constructor}\par
00130     Polynomial pc(pn);\par
00131     assert((pc.get_monomials().crbegin()->second.get_coeff() == 1) && {\cf22 "Error on copy Polynomial constructor: coeff is not copy coeff!"});\par
00132     assert((pc.get_monomials().crbegin()->second.get_degree() == 1) && {\cf22 "Error on copy Polynomial constructor: degree is not copy degree!"});\par
00133     assert((pc.get_degree() == 1) && {\cf22 "Error on copy Polynomial constructor: polynomial degree is not copy degree!"});\par
00134     {\cf20 // Move constructor}\par
00135     Polynomial pm(Polynomial(std::map<int, Monomial>(\{\{2, Monomial(2, 2)\}\})));\par
00136     assert((pm.get_monomials().crbegin()->second.get_coeff() == 2) && {\cf22 "Error on move Polynomial constructor: coeff is not move coeff!"});\par
00137     assert((pm.get_monomials().crbegin()->second.get_degree() == 2) && {\cf22 "Error on move Polynomial constructor: degree is not move degree!"});\par
00138     assert((pm.get_degree() == 2) && {\cf22 "Error on move Polynomial constructor: polynomial degree is not move degree!"});\par
00139     {\cf20 //--------------------------------------}\par
00140     {\cf20 //             ASSIGMENT}\par
00141     {\cf20 //--------------------------------------}\par
00142     {\cf20 // Copy assigment}\par
00143     pc = pm;\par
00144     assert((pc.get_monomials().crbegin()->second.get_coeff() == 2) && {\cf22 "Error on copy assigment operator: coeff is not copy coeff!"});\par
00145     assert((pc.get_monomials().crbegin()->second.get_degree() == 2) && {\cf22 "Error on copy assigment operator: degree is not copy degree!"});\par
00146     assert((pc.get_degree() == 2) && {\cf22 "Error on copy assigment operator: polynomial degree is not copy degree!"});\par
00147     {\cf20 // Move assigment}\par
00148     pm = Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}\}));\par
00149     assert((pm.get_monomials().crbegin()->second.get_coeff() == 3) && {\cf22 "Error on move assigment operator: coeff is not move coeff!"});\par
00150     assert((pm.get_monomials().crbegin()->second.get_degree() == 3) && {\cf22 "Error on move assigment operator: degree is not move degree!"});\par
00151     assert((pm.get_degree() == 3) && {\cf22 "Error on move assigment operator: polynomial degree is not move degree!"});\par
00152     {\cf20 //--------------------------------------}\par
00153     {\cf20 //             COMPARISON}\par
00154     {\cf20 //--------------------------------------}\par
00155     {\cf17 const} Polynomial p2(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})), p4(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}));\par
00156     {\cf20 // Equality}\par
00157     assert((p2 == p2) && (p2 == Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\}))) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) == p2) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) == Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\}))) && {\cf22 "Error on equal operator: equal monomials are not diffent!"});\par
00158     assert((p2 != p4) && (p2 != Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}))) && (Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) != p2) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) != Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}))) && {\cf22 "Error on equal operator: diffent monomials are not equal!"});\par
00159     {\cf20 // Size}\par
00160     assert((p4 > p2) && (p4 > Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\}))) && (Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) > p2) && (Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) > Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\}))) && {\cf22 "Error on greater monomial operator!"});\par
00161     assert((p2 < p4) && (p2 < Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}))) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) < p4) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) < Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}))) && {\cf22 "Error on lesser monomial operator!"});\par
00162     assert((p4 >= p2 && p4 >= p4) && (p4 >= Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) && p4 >= Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}))) && (Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) >= p2 && Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) >= p4) && (Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) >= Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) && Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) >= Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\}))) && {\cf22 "Error on greater or equal monomial operator!"});\par
00163     assert((p2 <= p4 && p2 <= p2) && (p2 <= Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) && p2 <= Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\}))) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) <= p4 && Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) <= p2) && (Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) <= Polynomial(std::map<int, Monomial>(\{\{3, Monomial(3, 3)\}, \{4, Monomial(4, 4)\}\})) && Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\})) >= Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(2, 2)\}\}))) && {\cf22 "Error on lesser or equal monomial operator!"});\par
00164     {\cf20 //--------------------------------------}\par
00165     {\cf20 //             ARITHMETIC}\par
00166     {\cf20 //--------------------------------------}\par
00167     Polynomial pn1(std::map<int, Monomial>(\{\{1, Monomial(2, 1)\}, \{2, Monomial(2, 2)\}\})), pn3(std::map<int, Monomial>(\{\{1, Monomial(2, 1)\}, \{3, Monomial(3, 3)\}\}));\par
00168     {\cf20 // Addition}\par
00169     assert(pn1 + pn3 == Polynomial(std::map<int, Monomial>(\{\{1, Monomial(4, 1)\}, \{2, Monomial(2, 2)\}, \{3, Monomial(3, 3)\}\})) && {\cf22 "Error on addition operator: wrong results"});\par
00170     {\cf20 // Substraction}\par
00171     assert(pn1 - pn3 == Polynomial(std::map<int, Monomial>(\{\{2, Monomial(2, 2)\}, \{3, Monomial(-3, 3)\}\})) && {\cf22 "Error on substraction operator: wrong results"});\par
00172     {\cf20 // Multiplication}\par
00173     assert(pn1 * pn3 == Polynomial(std::map<int, Monomial>(\{\{2, Monomial(4, 2)\}, \{3, Monomial(4, 3)\}, \{4, Monomial(6, 4)\}, \{5, Monomial(6, 5)\}\})) && {\cf22 "Error on multiplication operator: wrong results"});\par
00174     {\cf20 // Division}\par
00175     assert(pn3 / pn1 == Polynomial(std::map<int, Monomial>(\{\{0, Monomial(-1.5, 0)\}, \{1, Monomial(1.5, 1)\}\})) && {\cf22 "Error on division operator: wrong results"});\par
00176     {\cf20 // Modulus}\par
00177     assert(pn3 % pn1 == Polynomial(std::map<int, Monomial>(\{\{1, Monomial(5, 1)\}\})) && {\cf22 "Error on modulus operator: wrong results"});\par
00178     {\cf20 //--------------------------------------}\par
00179     {\cf20 //               STREAM}\par
00180     {\cf20 //--------------------------------------}\par
00181     std::stringstream ss;\par
00182     {\cf17 const} Polynomial ps(std::map<int, Monomial>(\{\{0, Monomial(1, 0)\}, \{1, Monomial(1, 1)\}, \{2, Monomial(1, 2)\}\}));\par
00183     assert(((ss << ps).str() == {\cf22 "1x^2 1x^1 1x^0 "}) && {\cf22 "Error on stream operator!"}); {\cf20 //"x^2 + x + 1"}\par
00184     {\cf20 //--------------------------------------}\par
00185     {\cf20 //                 MISC}\par
00186     {\cf20 //--------------------------------------}\par
00187     {\cf20 // Expression getter}\par
00188     assert((ps.get_expression() == {\cf22 "1x^2 1x^1 1x^0 "}) && {\cf22 "Error on expression getter!"});\par
00189     {\cf20 // Value getter}\par
00190     assert((ps.get_value(1) == 3) && (ps.get_value(2) == 7) && {\cf22 "Error on value getter!"});\par
00191     {\cf20 //--------------------------------------}\par
00192     {\cf20 //               CALCULUS}\par
00193     {\cf20 //--------------------------------------}\par
00194     {\cf20 // Derivative getter}\par
00195     assert((ps.get_derivative() == Polynomial(std::map<int, Monomial>(\{\{0, Monomial(1, 0)\}, \{1, Monomial(2, 1)\}\}))) && {\cf22 "Error on derivative getter!"});\par
00196     {\cf20 // Integral getter}\par
00197     assert((ps.get_integral() == Polynomial(std::map<int, Monomial>(\{\{1, Monomial(1, 1)\}, \{2, Monomial(0.5, 2)\}, \{3, Monomial(1.0/3.0, 3)\}\}))) && {\cf22 "Error on integral getter!"});\par
00198     {\cf20 // Well done!}\par
00199     std::cout << {\cf22 "Polynomial tests passed!"} << std::endl;\par
00200     {\cf19 return} 0;\par
00201 \}\par
00206 {\cf18 int} main() \{{\cf19 return} test_monomial() + test_polynomial();\}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/eparser.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/eparser.cpp}
{\xe \v src/eparser.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main implementation file for the equation parser. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "eparser.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for eparser.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "src_2eparser_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main implementation file for the equation parser. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the implementation of the classes and functions for parsing polynomials and monomials.\par
It consists of two classes, the Parser class and the Lexer class.\par
The Parser class consists of two functions, one for parsing the entire input as a Polynomial and another for parsing a Monomial at a time.\par
The Lexer class just provides a token supplier for the Parser class.\par
}{
Definition in file {\b eparser.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
eparser.cpp\par \pard\plain 
{\tc\tcl2 \v src/eparser.cpp}
{\xe \v src/eparser.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00009 {\cf21 #include "eparser.h"}\par
00014 emthp::Lexer::Lexer({\cf17 const} std::string& input) noexcept : _input(this->clean(input)), _pos(0) \{\}\par
00020 emthp::Lexer& emthp::Lexer::operator =({\cf17 const} emthp::Lexer& ogn) {\cf17 noexcept} \{\par
00021     this->_input = ogn._input;\par
00022     this->_pos = ogn._pos;\par
00023     {\cf19 return} *{\cf17 this};\par
00024 \};\par
00029 emthp::Token emthp::Lexer::next() noexcept \{\par
00030     {\cf19 if} (this->_pos >= this->_input.size()) \{{\cf19 return} \{emthp::TokenType::T_EOF, \{0\}\};\} {\cf20 //Returs EOL on end of _input}\par
00031     {\cf19 switch} (this->_input[this->_pos]) \{\par
00032         {\cf19 case} {\cf23 '+'}: this->_pos++; {\cf19 return} \{emthp::TokenType::T_PLUS, \{0\}\};\par
00033         {\cf19 case} {\cf23 '-'}: this->_pos++; {\cf19 return} \{emthp::TokenType::T_MINUS, \{0\}\};\par
00034         {\cf19 case} {\cf23 '^'}: this->_pos++; {\cf19 return} \{emthp::TokenType::T_EXPONENT, \{0\}\};\par
00035         {\cf19 case} {\cf23 'x'}: this->_pos++; {\cf19 return} \{emthp::TokenType::T_VARIABLE, \{0\}\};\par
00036         {\cf19 case} {\cf23 '*'}: {\cf19 case} {\cf23 '/'}: this->_pos++; {\cf19 return} next();\par
00037         {\cf19 default}:\par
00038             {\cf18 double} number = this->read_number();\par
00039             {\cf19 while}({\cf17 true}) \{\par
00040                 {\cf19 switch} (this->_input[this->_pos]) \{\par
00041                     {\cf19 case} {\cf23 '*'}: this->_pos++; number *= this->read_number(); {\cf19 break};\par
00042                     {\cf19 case} {\cf23 '/'}: this->_pos++; number /= this->read_number(); {\cf19 break};\par
00043                     {\cf19 case} {\cf23 '^'}: this->_pos++; number = std::pow(number, this->read_number()); {\cf19 break};\par
00044                     {\cf19 default}: {\cf19 return} \{emthp::TokenType::T_NUMBER, \{number\}\};\par
00045                 \}\par
00046             \}\par
00047     \}\par
00048 \}\par
00052 {\cf18 void} emthp::Lexer::back() noexcept \{\par
00053     {\cf19 if} (this->_pos <= 0) \{{\cf19 return};\} \par
00054     {\cf19 if} (emthp::Lexer::is_digit(this->_input[this->_pos-1])) \{{\cf19 while} (emthp::Lexer::is_digit(this->_input[this->_pos-1])) \{this->_pos--;\} {\cf19 return};\}\par
00055     this->_pos--;{\cf19 return};\par
00056 \}\par
00062 std::string emthp::Lexer::clean({\cf17 const} std::string& input) {\cf17 noexcept} \{\par
00063     {\cf18 long} {\cf18 unsigned} {\cf18 int} pos = 0; std::string string;\par
00064     {\cf19 while} (pos < input.size()) \{\par
00065         {\cf19 switch} (input[pos]) \{\par
00066             {\cf19 case} {\cf23 '+'}: {\cf18 string} += {\cf23 '+'}; {\cf19 break};\par
00067             {\cf19 case} {\cf23 '-'}: {\cf18 string} += {\cf23 '-'}; {\cf19 break};\par
00068             {\cf19 case} {\cf23 '*'}: {\cf18 string} += {\cf23 '*'}; {\cf19 break};\par
00069             {\cf19 case} {\cf23 '/'}: {\cf18 string} += {\cf23 '/'}; {\cf19 break};\par
00070             {\cf19 case} {\cf23 '^'}: {\cf18 string} += {\cf23 '^'}; {\cf19 break};\par
00071             {\cf19 case} {\cf23 'x'}: {\cf18 string} += {\cf23 'x'}; {\cf19 break};\par
00072             {\cf19 default}: {\cf19 if} (emthp::Lexer::is_digit(input[pos])) \{{\cf18 string} += input[pos];\} {\cf19 break};\par
00073         \}\par
00074         pos++;\par
00075     \}\par
00076     {\cf19 return} string;\par
00077 \}\par
00082 {\cf18 double} emthp::Lexer::read_number() noexcept \{\par
00083     std::string snum;\par
00084     {\cf19 while} (this->_pos < this->_input.size() && emthp::Lexer::is_digit(this->_input[this->_pos])) \{\par
00085         snum += this->_input[this->_pos];\par
00086         this->_pos++;\par
00087     \}\par
00088     {\cf19 if} (snum.empty()) \{{\cf19 return} 1;\}\par
00089     {\cf19 return} std::stod(snum); {\cf20 // CHECK : 2x^2 -- 8x^3/3 ;;;.......................4x^1 + 2x\'E2\'81\'B6}\par
00090 \}\par
00095 emthp::Parser::Parser({\cf17 const} std::string& input) noexcept : _lexer(input) \{\};\par
00101 emthp::Parser& emthp::Parser::operator =({\cf17 const} emthp::Parser& ogn) {\cf17 noexcept} \{this->_lexer = ogn._lexer; {\cf19 return} *{\cf17 this};\};\par
00106 emth::Polynomial emthp::Parser::parse_polynomial() noexcept \{\par
00107     emth::Polynomial polynomial;\par
00108     {\cf19 while} ({\cf17 true}) \{{\cf19 if}(!polynomial.push_monomial(std::move(this->parse_monomial()))) \{{\cf19 return} polynomial;\}\}\par
00109 \}\par
00114 emth::Monomial emthp::Parser::parse_monomial() noexcept \{\par
00115     emth::Monomial monomial(0, 0);\par
00116     monomial.set_coeff(this->parse_number());\par
00117     {\cf18 bool} v = {\cf17 false}; {\cf18 bool} e = {\cf17 false};\par
00118     {\cf19 while} (!v || !e) \{\par
00119         emthp::Token token = this->_lexer.next();\par
00120         {\cf19 switch} (token.type) \{\par
00121             {\cf19 case} emthp::TokenType::T_VARIABLE: v = {\cf17 true}; {\cf19 break};\par
00122             {\cf19 case} emthp::TokenType::T_EXPONENT: {\cf19 if} (v) \{e = {\cf17 true};\} {\cf19 break};\par
00123             {\cf19 case} emthp::TokenType::T_PLUS: {\cf19 case} emthp::TokenType::T_MINUS: {\cf19 case} emthp::TokenType::T_NUMBER: {\cf19 if} (v) \{monomial.set_degree(1); this->_lexer.back();\} {\cf19 return} monomial;\par
00124             {\cf19 case} emthp::TokenType::T_EOF: {\cf19 if} (v) \{monomial.set_degree(1);\} {\cf19 return} monomial;\par
00125         \}\par
00126     \}\par
00127     monomial.set_degree(({\cf18 int}) this->parse_number());\par
00128     {\cf19 return} monomial;\par
00129 \}\par
00134 {\cf18 double} emthp::Parser::parse_number() noexcept \{\par
00135     {\cf18 bool} positive = {\cf17 true};\par
00136     {\cf19 while}({\cf17 true}) \{\par
00137         emthp::Token token = this->_lexer.next();\par
00138         {\cf19 switch}(token.type) \{\par
00139             {\cf19 case} emthp::TokenType::T_MINUS: positive = !positive; {\cf19 break};\par
00140             {\cf19 case} emthp::TokenType::T_NUMBER: {\cf19 return} positive ? token.value : -token.value;\par
00141             {\cf19 case} emthp::TokenType::T_VARIABLE: this->_lexer.back(); {\cf19 return} positive ? 1 : -1;\par
00142             {\cf19 case} emthp::TokenType::T_EOF: {\cf19 return} 0;\par
00143         \}\par
00144     \}\par
00145 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/eparser.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v test/eparser.cpp}
{\xe \v test/eparser.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main test file for the equation parser. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <gtest/gtest.h>}\par
{\f2 #include "eparser.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for eparser.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2eparser_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EParserTest}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that provides a test fixture for the test cases. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, Lexer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, CompoundLexer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, ArithmeticLexer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, Variables)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, Compound)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, Signs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, Noise)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_F} ({\b EParserTest}, Edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that runs all the declared tests. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main test file for the equation parser. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains a text fixture class and all the test cases.\par
It consists of the {\b EParserTest} classe that provides the test fixture for all the tests.\par
Then it contains all the test cases, for testing correct execution. \par
}{
Definition in file {\b eparser.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:eparser.cpp}
{\xe \v eparser.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function that runs all the declared tests. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{The console arguments count \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{The console arguments as a array of char arrays \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(0) If all tests passed \par
(1) If one or more tests failed \par
}}}{
Definition at line {\b 169} of file {\b eparser.cpp}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , ArithmeticLexer )}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test lexer functionality with arithmetic expressions \par
}
}{
Definition at line {\b 104} of file {\b eparser.cpp}.}\par
{
\ql
References {\b emthp::Token::type}, and {\b emthp::Token::value}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , Compound )}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test parser functionality with polynomial expressions \par
}
}{
Definition at line {\b 140} of file {\b eparser.cpp}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , CompoundLexer )}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test lexer functionality with compund expressions \par
}
}{
Definition at line {\b 77} of file {\b eparser.cpp}.}\par
{
\ql
References {\b emthp::Token::type}, and {\b emthp::Token::value}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , Edge )}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test parser edge cases \par
}
}{
Definition at line {\b 161} of file {\b eparser.cpp}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , Lexer )}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test lexer functionality with simple expressions \par
}
}{
Definition at line {\b 42} of file {\b eparser.cpp}.}\par
{
\ql
References {\b emthp::Token::type}, and {\b emthp::Token::value}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , Noise )}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test parser functionality with noise in the expressions \par
}
}{
Definition at line {\b 154} of file {\b eparser.cpp}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , Signs )}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test parser functionality with sign expressions \par
}
}{
Definition at line {\b 144} of file {\b eparser.cpp}.}\par
}
{\xe \v TEST_F\:eparser.cpp}
{\xe \v eparser.cpp\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_F ({\b EParserTest} , Variables )}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Test:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test parser functionality with monomial expressions \par
}
}{
Definition at line {\b 131} of file {\b eparser.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
eparser.cpp\par \pard\plain 
{\tc\tcl2 \v test/eparser.cpp}
{\xe \v test/eparser.cpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00008 {\cf21 #include <gtest/gtest.h>}\par
00009 {\cf21 #include "eparser.h"}\par
00014 {\cf17 class }EParserTest : {\cf17 public} ::testing::Test \{\par
00015     {\cf17 public}:\par
00020         EParserTest() : lexer({\cf22 ""}), parser({\cf22 ""}) \{\};\par
00025         {\cf18 void} set_input({\cf17 const} std::string &input) \{\par
00026             this->lexer = emthp::Lexer(input);\par
00027             this->parser = emthp::Parser(input);\par
00028         \}\par
00029     {\cf17 protected}:\par
00033         emthp::Lexer lexer;\par
00037         emthp::Parser parser;\par
00038 \};\par
00042 TEST_F(EParserTest, Lexer) \{\par
00043     emthp::Token token;\par
00044     this->set_input({\cf22 "2x^2 - 8"});\par
00045 \par
00046     token = this->lexer.next();\par
00047     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00048     ASSERT_EQ(token.value, 2.0);\par
00049 \par
00050     token = this->lexer.next();\par
00051     ASSERT_EQ(token.type, emthp::TokenType::T_VARIABLE);\par
00052     ASSERT_EQ(token.value, 0.0);\par
00053 \par
00054     token = this->lexer.next();\par
00055     ASSERT_EQ(token.type, emthp::TokenType::T_EXPONENT);\par
00056     ASSERT_EQ(token.value, 0.0);\par
00057 \par
00058     token = this->lexer.next();\par
00059     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00060     ASSERT_EQ(token.value, 2.0);\par
00061 \par
00062     token = this->lexer.next();\par
00063     ASSERT_EQ(token.type, emthp::TokenType::T_MINUS);\par
00064     ASSERT_EQ(token.value, 0.0);\par
00065 \par
00066     token = this->lexer.next();\par
00067     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00068     ASSERT_EQ(token.value, 8.0);\par
00069 \par
00070     token = this->lexer.next();\par
00071     ASSERT_EQ(token.type, emthp::TokenType::T_EOF);\par
00072     ASSERT_EQ(token.value, 0.0);\par
00073 \}\par
00077 TEST_F(EParserTest, CompoundLexer) \{\par
00078     emthp::Token token;\par
00079     this->set_input({\cf22 "1.11x^2.22"});\par
00080     \par
00081     token = this->lexer.next();\par
00082     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00083     ASSERT_EQ(token.value, 1.11);\par
00084 \par
00085     token = this->lexer.next();\par
00086     ASSERT_EQ(token.type, emthp::TokenType::T_VARIABLE);\par
00087     ASSERT_EQ(token.value, 0.0);\par
00088 \par
00089     token = this->lexer.next();\par
00090     ASSERT_EQ(token.type, emthp::TokenType::T_EXPONENT);\par
00091     ASSERT_EQ(token.value, 0.0);\par
00092 \par
00093     token = this->lexer.next();\par
00094     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00095     ASSERT_EQ(token.value, 2.22);\par
00096     \par
00097     token = this->lexer.next();\par
00098     ASSERT_EQ(token.type, emthp::TokenType::T_EOF);\par
00099     ASSERT_EQ(token.value, 0.0);\par
00100 \}\par
00104 TEST_F(EParserTest, ArithmeticLexer) \{\par
00105     emthp::Token token;\par
00106     this->set_input({\cf22 "2*8/4^3 x^ 2^2"});\par
00107     \par
00108     token = this->lexer.next();\par
00109     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00110     ASSERT_EQ(token.value, 64.0);\par
00111 \par
00112     token = this->lexer.next();\par
00113     ASSERT_EQ(token.type, emthp::TokenType::T_VARIABLE);\par
00114     ASSERT_EQ(token.value, 0.0);\par
00115 \par
00116     token = this->lexer.next();\par
00117     ASSERT_EQ(token.type, emthp::TokenType::T_EXPONENT);\par
00118     ASSERT_EQ(token.value, 0.0);\par
00119 \par
00120     token = this->lexer.next();\par
00121     ASSERT_EQ(token.type, emthp::TokenType::T_NUMBER);\par
00122     ASSERT_EQ(token.value, 4.0);\par
00123     \par
00124     token = this->lexer.next();\par
00125     ASSERT_EQ(token.type, emthp::TokenType::T_EOF);\par
00126     ASSERT_EQ(token.value, 0.0);\par
00127 \}\par
00131 TEST_F(EParserTest, Variables) \{\par
00132     this->set_input({\cf22 "x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(1, 1));\par
00133     this->set_input({\cf22 "2x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(2, 1));\par
00134     this->set_input({\cf22 "x^2"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(1, 2));\par
00135     this->set_input({\cf22 "2x^2"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(2, 2));\par
00136 \}\par
00140 TEST_F(EParserTest, Compound) \{this->set_input({\cf22 "2x^2 - 2x + 2"}); ASSERT_EQ(this->parser.parse_polynomial(), emth::Polynomial(\{emth::Monomial(2, 2), emth::Monomial(-2, 1), emth::Monomial(2, 0)\}));\}\par
00144 TEST_F(EParserTest, Signs) \{\par
00145     this->set_input({\cf22 "-x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(-1, 1));\par
00146     this->set_input({\cf22 "--x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(1, 1));\par
00147     this->set_input({\cf22 "---x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(-1, 1));\par
00148     this->set_input({\cf22 "-+x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(-1, 1));\par
00149     this->set_input({\cf22 "+-+x"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(-1, 1));\par
00150 \}\par
00154 TEST_F(EParserTest, Noise) \{\par
00155     this->set_input({\cf22 "(1)<\'B7\'B7\'B7(0)<\'B7\'B7\'B7_x_\'B7\'B7\'B7>^\{2\}"}); ASSERT_EQ(this->parser.parse_monomial(), emth::Monomial(10, 2));\par
00156     this->set_input({\cf22 "(1)<\'B7\'B7\'B7(0)<\'B7\'B7\'B7_x_\'B7\'B7\'B7>^\{2\} - (0)<\'B7\'B7\'B7(5)<\'B7\'B7\'B7_x_\'B7\'B7\'B7>^\{2\}"}); ASSERT_EQ(this->parser.parse_polynomial(), emth::Polynomial(\{emth::Monomial(5, 2)\}));\par
00157 \}\par
00161 TEST_F(EParserTest, Edge) \{this->set_input({\cf22 ""}); ASSERT_EQ(this->parser.parse_polynomial(), emth::Polynomial());\}\par
00169 {\cf18 int} main({\cf18 int} argc, {\cf18 char}** argv) \{testing::InitGoogleTest(&argc, argv); {\cf19 return} RUN_ALL_TESTS();\}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
